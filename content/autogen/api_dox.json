var gizmo_dox_data = {
	'PointCollisionTest' : [
		['PointCollisionTest.testQuad', 'PointCollisionTest.testQuad( self,  l,b,w,h,  x,y )', '\nEasy* hit-testing for quad regions.\n\nNeeds renaming.\n\nAPI: >= 13.01\n', 'PointCollisionTest.lua#L12']
		],
	'acf' : [
		['acf.getAStabHeading', 'acf.getAStabHeading()', ' Returns: Aritifial stability input: heading(rudder): range: -1 to 1\n', 'api_acf.cpp#L116'],
		['acf.getAStabPitch', 'acf.getAStabPitch()', ' Returns: Aritifial stability input: pitch: range: -1 to 1\n', 'api_acf.cpp#L104'],
		['acf.getAStabRoll', 'acf.getAStabRoll()', ' Returns: Aritifial stability input: roll: range: -1 to 1\n', 'api_acf.cpp#L110'],
		['acf.getAlpha', 'acf.getAlpha()', ' Returns: Aircraft attitude: alpha in degrees.\n', 'api_acf.cpp#L96'],
		['acf.getAltAgl', 'acf.getAltAgl()', ' Returns: Aircraft altitude above ground level in meters.\n', 'api_acf.cpp#L16'],
		['acf.getAltMsl', 'acf.getAltMsl()', ' Returns: Aircraft altitude above mean-sea-level in meters.\n', 'api_acf.cpp#L23'],
		['acf.getAuthor', 'acf.getAuthor()', ' Returns: Aircraft Author from .acf file as string value.\n', 'api_acf.cpp#L30'],
		['acf.getBeta', 'acf.getBeta()', ' Returns: Aircraft attitude: beta in degrees.\n', 'api_acf.cpp#L124'],
		['acf.getDescription', 'acf.getDescription()', ' Returns: Description string from ACF file, as set in PlaneMaker.\n', 'api_acf.cpp#L46'],
		['acf.getEncryptedScripts', 'acf.getEncryptedScripts()', '\nReturns: boolean. \n\nTrue if booted from init.lua.aes\n\n<code>\nlocal secure_mode = acf.getEncryptedScripts()\n</code>\n\nAPI: 11.11+\n', 'api_acf.cpp#L376'],
		['acf.getFCHeading', 'acf.getFCHeading()', ' Returns: Value of flight control pitch.\n', 'api_acf.cpp#L143'],
		['acf.getFCPitch', 'acf.getFCPitch()', ' Returns: Value of flight control pitch.\n', 'api_acf.cpp#L131'],
		['acf.getFCRoll', 'acf.getFCRoll()', ' Returns: Value of flight control pitch.\n', 'api_acf.cpp#L137'],
		['acf.getFilename', 'acf.getFilename()', ' Returns: Aircraft filename, no folder info.\n Eg: "c4.acf"\n', 'api_acf.cpp#L62'],
		['acf.getFolder', 'acf.getFolder()', ' Returns: Full path to aircraft folder as string.\n Eg: "/Applications/X-Plane 9 Demo/Aircraft/General Aviation/Cirrus Jet/"\n', 'api_acf.cpp#L73'],
		['acf.getGS', 'acf.getGS()', ' Returns: Aircraft ground speed in meters per second.\n', 'api_acf.cpp#L151'],
		['acf.getGearDeployState', 'acf.getGearDeployState()', ' Returns: Aircraft landing gear: actual state. Lua table of values as ratios.\n\n\tEg: gear_state = { acf.getGearDeployState() }\n\tgear_state is now somthing like [ 1, 0.5, 0.75,  1,1,1,  1,1,1, 1 ]\n', 'api_acf.cpp#L466'],
		['acf.getGearHandleState', 'acf.getGearHandleState()', ' Returns: Aircraft landing gear handle selection request value. 0 = gear up, 1 = gear down.\n', 'api_acf.cpp#L485'],
		['acf.getHeading', 'acf.getHeading()', ' Returns: Aircraft attitude: magnetic heading in degrees.\n', 'api_acf.cpp#L159'],
		['acf.getHeadingTrue', 'acf.getHeadingTrue()', ' Returns: Aircraft attitude: true heading in degrees.\n', 'api_acf.cpp#L165'],
		['acf.getIAS', 'acf.getIAS()', ' Returns: Indicated Air Speed in Meters/Second.\n', 'api_acf.cpp#L173'],
		['acf.getKIAS', 'acf.getKIAS()', ' Returns: Indicated Air Speed in Knots.\n', 'api_acf.cpp#L179'],
		['acf.getLat', 'acf.getLat()', ' Returns: latitude of aircraft as decimal number.\n', 'api_acf.cpp#L187'],
		['acf.getLiveryFolder', 'acf.getLiveryFolder()', ' Returns: Path of Livery folder relative to X-Plane app.\n Eg: "Aircraft/General Aviation/Cirrus Jet/liveries/red"\n \n API >= 11.9.1\n', 'api_acf.cpp#L207'],
		['acf.getLiveryName', 'acf.getLiveryName()', ' Returns: Name of livery in use.\n Eg: "red"\n \n API >= 11.9.1\n', 'api_acf.cpp#L195'],
		['acf.getLon', 'acf.getLon()', ' Returns: longitude of aircraft as decimal number.\n', 'api_acf.cpp#L220'],
		['acf.getP', 'acf.getP()', '\nReturns: float\n\nThe roll rotation rates (relative to the flight)\n\n<code>\nlocal roll_rate = acf.getP()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L252'],
		['acf.getP_dot', 'acf.getP_dot()', '\nReturns: float\n\nThe roll angular acceleration (relative to the flight)\n\n<code>\nlocal roll_acc_rate = acf.getP_dot()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L268'],
		['acf.getPitch', 'acf.getPitch()', '\nReturns: float\n\nThe pitch of the airframe.\n\n<code>\nlocal acf_pitch = acf.getPitch()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L284'],
		['acf.getPosition', 'acf.getPosition()', ' Returns: lat,lon,alt_msl\n \n API: >= 11.5.18\n', 'api_acf.cpp#L228'],
		['acf.getPositionGL', 'acf.getPositionGL()', ' See: gfx.getAircraftPositionGL()\n \n API: >= 11.5.18\n', 'api_acf.cpp#L241'],
		['acf.getQ', 'acf.getQ()', '\nReturns: float\n\nThe pitch rotation rates (relative to the flight)\n\n<code>\nlocal pitch_rate = acf.getQ()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L300'],
		['acf.getQ_dot', 'acf.getQ_dot()', 'Returns: float\n\nThe pitch angular acceleration (relative to the flight)\n\n<code>\nlocal pitch_rate = acf.getQ()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L316'],
		['acf.getR', 'acf.getR()', '\nReturns: float\n\nThe yaw rotation rates (relative to the flight)\n\n<code>\nlocal yaw_rate = acf.getR()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L343'],
		['acf.getR_dot', 'acf.getR_dot()', '\nReturns: float\n\nThe yaw angular acceleration rates (relative to the flight)\n\n<code>\nlocal yaw_rate = acf.getR()\n</code>\n\nAPI: >= 12.01\n', 'api_acf.cpp#L359'],
		['acf.getRelativeFolder', 'acf.getRelativeFolder()', ' Returns: String containing relative path to X-Plane folder, includes trailing slash. All slashes are set to /\n Eg: "Aircraft/General Aviation/Cirrus Jet/"\n', 'api_acf.cpp#L84'],
		['acf.getRoll', 'acf.getRoll()', '\nReturns: float\n\nThe airframe roll value in degrees.\n\nAPI: >= 12.01\n', 'api_acf.cpp#L331'],
		['acf.getSessionTime', 'acf.getSessionTime()', '\nReturns: float\n\nNumber of seconds that the airframe has been flown for this sim-session.\n \nAPI: 11.4+\n', 'api_acf.cpp#L397'],
		['acf.getTAS', 'acf.getTAS()', ' Returns: Aircraft true airspeed in meters per second.\n', 'api_acf.cpp#L430'],
		['acf.getTrack', 'acf.getTrack()', ' Returns: Aircraft track-heading across ground in degrees.\n', 'api_acf.cpp#L435'],
		['acf.getVS', 'acf.getVS()', ' Returns: Aircraft vertical speed in meters per second.\n', 'api_acf.cpp#L440'],
		['acf.getYokeHeading', 'acf.getYokeHeading()', ' Returns: pilot heading input as decimal number.\n', 'api_acf.cpp#L459'],
		['acf.getYokePitch', 'acf.getYokePitch()', ' Returns: pilot pitch input as decimal number.\n', 'api_acf.cpp#L447'],
		['acf.getYokeRoll', 'acf.getYokeRoll()', ' Returns: pilot roll input as decimal number.\n', 'api_acf.cpp#L453'],
		['acf.load', 'acf.load( xp_relative_fiilename )', '\neg:  acf.load("Aircraft/Heavy Metal/B747-400 United/United-Air.acf")\n\n \n Load the specified ACF file for the user to fly.\n \n This call will reset the Gizmo engine and can be used to instruct X-Plane to load any valid ACF file inside the X-Plane folder.\n \n API: >= 12.9.14\n \n', 'api_acf.cpp#L544'],
		['acf.reload', 'acf.reload()', '\n Attempts to reload the users currnetly selected aircraft.\n This can be performed to make certain content changes take effect.\n It also has the effect of rebinding any objects to new datarefs that\n were created between the time that the user first loaded the aircraft\n and invoked the ./scripts/init.lua file and when this function is called.\n', 'api_acf.cpp#L496']
		],
	'camera' : [
		['camera.getAttitude', 'camera.getAttitude()', '\nReturns: pitch,roll,heading\nEg: p,r,h = camera.getAttitude()\n\nAPI: >= 11.11.14\n', 'api_camera.cpp#L27'],
		['camera.getControl', 'camera.getControl()', ' Ask X-Plane for control of the camera.\n', 'api_camera.cpp#L62'],
		['camera.getControlGreedy', 'camera.getControlGreedy()', ' Ask X-Plane for control of the camera.\n', 'api_camera.cpp#L79'],
		['camera.getFOV', 'camera.getFOV()', ' Returns: Current field of view.\n fov = camera.getFOV()\n', 'api_camera.cpp#L97'],
		['camera.getPosition', 'camera.getPosition()', ' Returns: latitude, longitude, altitude\n latitude, longitude, altitude = camera.getPosition()\n \n API: >= 11.11.14\n', 'api_camera.cpp#L112'],
		['camera.getPositionGL', 'camera.getPositionGL()', ' Returns: x,y,z\n x,y,z = camera.getPositionGL()\n \n  API: >= 11.11.14\n', 'api_camera.cpp#L139'],
		['camera.getZoom', 'camera.getZoom()', ' Returns: zoom\n zoom = camera.getZoom()\n', 'api_camera.cpp#L158'],
		['camera.lookAt', 'camera.lookAt( lat, lot, altitude )', ' Rotate the camera in such a way that it is (hopefully) facing the specified location in the world.\n', 'api_camera.cpp#L174'],
		['camera.lookAtGL', 'camera.lookAtGL( x,y,z )', ' Rotate the camera in such a way that it is facing the specified location in OpenGL space.\n', 'api_camera.cpp#L219'],
		['camera.releaseControl', 'camera.releaseControl()', ' Release the Camera back into X-Planes hands.\n', 'api_camera.cpp#L253'],
		['camera.setAttitude', 'camera.setAttitude( p,r,h )', ' Rotate the camera to face a specified orientation.\n', 'api_camera.cpp#L320'],
		['camera.setFOV', 'camera.setFOV( fov )', ' Set the field of view for the camera.\n', 'api_camera.cpp#L336'],
		['camera.setPosition', 'camera.setPosition( lat,lon,alt )', ' Set the camera location in world-coordinates.\n', 'api_camera.cpp#L267'],
		['camera.setPositionGL', 'camera.setPositionGL( x,y,z )', ' Set the camera position using OpenGL-coordinates.\n', 'api_camera.cpp#L299'],
		['camera.setZoom', 'camera.setZoom( zoom )', ' Set the zoom value for the camera.\n \n API: 11.4+\n \n', 'api_camera.cpp#L352']
		],
	'color' : [
		['color.read_me', 'color.read_me()', '\nGizmo64 provides a table of common color names that can be used to make your code easier to read and write.\n\nPlease see this file for more information:\nhttps://github.com/benrussell/Gizmo-Firmware/blob/master/firmware/core/color_api.lua\n\n<code>\ngfx.setColor( color.red )\n</code>\n\nColors available as of 2014.04.19\n\ncolor.red\ncolor.green\ncolor.blue\n\ncolor.yellow\ncolor.orange\ncolor.magenta\n\ncolor.black\ncolor.white\n\ncolor.dark_gray\ncolor.light_gray\ncolor.gray\ncolor.grey\n\ncolor.bg_gray\ncolor.bg_gray_bright\n\n\nAPI: >= 14.04\n', 'color_api.lua#L12']
		],
	'console' : [
		['console.error', 'console.error( message )', '\nLog an error message to the console.\n', 'console_api.lua#L30'],
		['console.log', 'console.log( message )', '\nLog a message to the console.\n', 'console_api.lua#L22'],
		['console.warn', 'console.warn( message )', '\nLog a warning message to the console.\n', 'console_api.lua#L14']
		],
	'coroutine' : [
		['coroutine.read_me', 'coroutine.read_me()', '\nStandard Lua coroutine support is available. \n', 'api_third_party_docs.cpp#L24']
		],
	'debug' : [
		['debug.read_me', 'debug.read_me()', '\nThe debug library is disabled for all third party content.\n\n', 'api_third_party_docs.cpp#L35']
		],
	'dref' : [
		['dref.getArraySize', 'dref.getArraySize( dref_id )', '\nReturns: array_element_count\n\nNumber of array elements the dref supports.\n\n<code>local array_size = dref.getArraySize( dr_MyCustomFloatArray )</code>\n\nAPI: >= broken!\n', 'api_dref.cpp#L594'],
		['dref.getBytes', 'dref.getBytes( dataref_id, start_at, number_to_fetch )', '\nReturns: Lua String\n\n<code>--Copy byte-string dataref value into a Lua variable.\n\nlocal dr_AcfAuthor = dref.getDataref("sim/acf/description/author")\n\nlocal dref_string_value_copy = dref.getBytes( dr_AcfAuthor, 1, 1024 )\n</code>\n\nAPI: >= 14.01\n', 'api_dref.cpp#L712'],
		['dref.getDataref', 'dref.getDataref( string_dataref_name )', '\nReturns: dref_id\n\nNOTE: This function does NOT accept "part numbers" as a shortcut for using array datarefs.\nThis will NOT work: dref.getDataref( "sim/dataref[99999]" )\n\nException: The weather datarefs for cloud and wind layers are NOT array datarefs but contain [0], [1] and [2] in the dataref name string.\nThese datarefs will work as expected.\n\nSee the documentation for dref.getFloatV(...), dref.getIntV(...), dref.getBytes(...), etc for more information about working with array datarefs.\n\n<code>--Locate the sims built-in anti-ice-switch dataref.\ndr_ice_switch = dref.getDataref("sim/cockpit/switches/ice")\n</code>\n\n<code>--check to see if the switch is on or off\nlocal switch_value = dref.getInt( dr_ice_switch )\nif( switch_value == 0 )then\n\t--switch is off\n\t\nelse if( switch_value == 1 )then\n\t--switch is on\n\t\nend\n</code>\n\nAPI: >= 12.01\n', 'api_dref.cpp#L626'],
		['dref.getFloat', 'dref.getFloat( dref_id )', '\nReturns: Floating point value for dataref specified by dref_id.\n\nSee dref.getDataref, dref.newFloat, dref.newInt, etc. for more information.\n\n<code>--Fetch the value of a dataref.\nlocal tmp_value = dref.getFloat( dref_id )\n</code>\n\nAPI: >= 12.01\n', 'api_dref.cpp#L876'],
		['dref.getFloatV', 'dref.getFloatV( dataref_id, start_at, number_to_fetch )', ' Returns: multiple values for dataref_id as decimal numbers\n \n See xp.getDataref("sim/foo") and xp.newDataref("custom/dataref") for more info.\n start_at refers to the part number in sim/dataref[99]\n \n In X-Plane, OBJ8 and C, part numbers start at 0.\n In Lua, part numbers start at 1.\n \n For this reason, the start_at parameter also starts at 1.\n \n If you want to get sim/dataref[0] use:\n value = xp.getFloatv( dataref_id, 1, 1 )\n \n We ask Gizmo to get us one value, starting at the first item.\n \n This seems a little bit annoying, but when you start using your tables of values\n with the rest of Luas functions you will understand why there is a little "shift"\n here when we push numbers in and out of X-Planes dataref systems.\t\n \n \n value = {}  -- Table to hold the array\n value    =    { xp.getFloatV(dataref_id, 1, n)}\n \n \n', 'api_dref.cpp#L812'],
		['dref.getInt', 'dref.getInt( dataref_id )', ' Returns: value of dataref_id Integer number\n See dref.getDataref("sim/foo") and dref.newDataref("custom/dataref") for more info.\n', 'api_dref.cpp#L971'],
		['dref.getIntV', 'dref.getIntV( dataref_id, start_at, number_to_fetch )', ' Returns: multiple values for dataref_id as numbers\n \n See xp.getDataref("sim/foo") and xp.newDataref("custom/dataref") for more info.\n start_at refers to the part number in sim/dataref[99]\n \n In X-Plane, OBJ8 and C, part numbers start at 0.\n In Lua, part numbers start at 1.\n \n For this reason, the start_at parameter also starts at 1.\n \n If you want to get sim/dataref[0] use:\n value = xp.getFloatv( dataref_id, 1, 1 )\n \n We ask Gizmo to get us one value, starting at the first item.\n \n This seems a little bit annoying, but when you start using your tables of values\n with the rest of Luas functions you will understand why there is a little "shift"\n here when we push numbers in and out of X-Planes dataref systems.\t\n \n \n value = {}  -- Table to hold the array\n value    =    { xp.getFloatV(dataref_id, 1, n)}\n \n \n \n', 'api_dref.cpp#L908'],
		['dref.getString', 'dref.getString( dataref_id )', ' Returns: Lua String\n \n Eg: \n foo = dref.getString( dr_id )\n print( foo )\n \n Note: Max string length is currently hard-limited to 1024 bytes.\n \n API: >= 11.10\n \n', 'api_dref.cpp#L759'],
		['dref.newByteArray', 'dref.newByteArray( string_dataref_name )', ' Returns: dref_id\n \n API: >= 11.8\n \n', 'api_dref.cpp#L493'],
		['dref.newFloat', 'dref.newFloat( dataref_name, OPT_hook_event_name )', '\nReturns: dref_id\n\nSimple:\n-------\nStorage of the value for this dataref will be completely managed by Gizmo64.\nYour code can update the value of the dataref using dref.getFloat(...) and dref.setFloat(...)\n<code>--create a new floating point dataref\n--store the handle for it in a variable called dr_MyCustomDataref\nlocal dr_MyCustomDataref = dref.newFloat("my/custom/dataref")\n\n--update the value of our dateref\ndref.setFloat( dr_MyCustomDataref, 1.234 )\n\n--retrieve the value of our dataref\nlocal tmp_val = dref.getFloat( dr_MyCustomDataref )</code>\n\nAdvanced:\n---------\nCreate a new floating point dataref that is fully managed by your code.\n\nThese "hooked" datarefs are ideal for managing input from a 3D Cokpit Object that utilizes "manipulators" for user input.\n\nThey can also be useful to provide a dataref that is always the value of a specific algorithm.\n<code>--create a new floating point dataref\n--store the handle for it in a variable called dr_MyCustomDataref\nlocal dr_MyCustomDataref = dref.newFloat("my/custom/dataref", "my_custom_dataref_hooks")\n\n--This code is called when a read of the dataref occurs.\nfunction my_custom_dataref_hooks_OnRead()\n\treturn acf.getIAS() * 10\nend\n\n--This code is called when a write to the dataref occurs.\nfunction my_custom_dataref_hooks_OnWrite( newValue )\n\tsound.say("dataref changed")\nend \n</code>\n\nAPI: >= 11.8\n', 'api_dref.cpp#L16'],
		['dref.newFloatArray', 'dref.newFloatArray( string_dataref_name )', '\nReturns: dref_id\n\nCreates a new float-array dataref.\n\nUse this when you want to use "part numbers" in your OBJ8 files.\n\nEg:\nmy/custom/float/array[2]\n\nValues are managed by Gizmo64. \nThe new dataref supports read+write access.\nAny other plugin may change their value at any time.\n\n<code>--Create a new custom dataref of type: float-array\nlocal dr_MyCustomFloatArray = dref.newFloatArray( "my/custom/float/array" )\n\n--Adjust the size of the float-array dataref. This can be done at any time.\ndref.setArraySize( dr_MyCustomFloatArray, 10 )\n\n--You can now use "part numbers" [0] through [9] in your OBJ8 files.\n</code>\n\nAPI: >= 11.8\n', 'api_dref.cpp#L264'],
		['dref.newInt', 'dref.newInt( dataref_name, OPT_hook_event_name )', '\nReturns: dref_id\n\nSimple:\n-------\nStorage of the value for this dataref will be completely managed by Gizmo64.\nYour code can update the value of the dataref using dref.getInt(...) and dref.setInt(...)\n<code>--create a new floating point dataref\n--store the handle for it in a variable called dr_MyCustomDataref\nlocal dr_MyCustomDataref = dref.newInt("my/custom/dataref")\n\n--update the value of our dateref\ndref.setInt( dr_MyCustomDataref, 5678 )\n\n--retrieve the value of our dataref\nlocal tmp_val = dref.getInt( dr_MyCustomDataref )</code>\n\nAdvanced:\n---------\nCreate a new integer dataref that is fully managed by your code.\n\nThese "hooked" datarefs are ideal for managing input from a 3D Cokpit Object that utilizes "manipulators" for user input.\n\nThey can also be useful to provide a dataref that is always the value of a specific algorithm.\n<code>--create a new floating point dataref\n--store the handle for it in a variable called dr_MyCustomDataref\nlocal dr_MyCustomDataref = dref.newInt("my/custom/dataref", "my_custom_dataref_hooks")\n\n--This code is called when a read of the dataref occurs.\nfunction my_custom_dataref_hooks_OnRead()\n\treturn acf.getIAS() * 10\nend\n\n--This code is called when a write to the dataref occurs.\nfunction my_custom_dataref_hooks_OnWrite( newValue )\n\tsound.say("dataref changed")\nend \n</code>\n\nAPI: >= 11.8\n', 'api_dref.cpp#L142'],
		['dref.newIntArray', 'dref.newIntArray( string_dataref_name )', '\nReturns: dref_id\n\nCreates a new int-array dataref.\n\nUse this when you want to use "part numbers" in your OBJ8 files.\n\nEg:\nmy/custom/float/array[2]\n\nValues are managed by Gizmo64. \nThe new dataref supports read+write access.\nAny other plugin may change their value at any time.\n\n<code>--Create a new custom dataref of type: float-array\nlocal dr_MyCustomIntArray = dref.newIntArray( "my/custom/int/array" )\n\n--Adjust the size of the float-array dataref. This can be done at any time.\ndref.setArraySize( dr_MyCustomIntArray, 10 )\n\n--You can now use "part numbers" [0] through [9] in your OBJ8 files.\n</code>\n\nAPI: >= 11.8\n', 'api_dref.cpp#L382'],
		['dref.publish', 'dref.publish( string_dataref_name )', 'Returns: nothing\nInforms DataRefEditor that a dataref with the specified name exists.\n\nThe dataref does not need to exist.\nThe dataref does not need to belong to Gizmo64.\n\nAPI: >= 13.07.05\n\n', 'api_dref.cpp#L1012'],
		['dref.setArraySize', 'dref.setArraySize( dref_id, new_size )', ' Returns: nothing\n \n Only valid when used on a custom-dataref that is owned and managed by Gizmo. Hooked datarefs manage their own size.\n \n API: >= 11.8\n \n', 'api_dref.cpp#L1089'],
		['dref.setAutoPublish', 'dref.setAutoPublish( boolean )', 'Returns: nothing\n\nToggles auto-publish feature of DRE for finer control of large projects.\n\nAPI: >= 13.07.05\n', 'api_dref.cpp#L1047'],
		['dref.setBytes', 'dref.setBytes( dataref_id, start_at, byte_string_var )', '\n Eg: dref.setBytes( dr_id, 1, "This is a new value payload." )\n \n', 'api_dref.cpp#L1113'],
		['dref.setFloat', 'dref.setFloat( dataref_id, value )', ' Push a new value into a dataref. Value is a decimal number.\n vvi = vvi * 2 \n dref.setFloat( dref_VVI, vvi )\n', 'api_dref.cpp#L1269'],
		['dref.setFloatV', 'dref.setFloatV( dataref_id, start_at, value1, value2, value3, ... )', ' OR\n tmp = { value1, value2, value3, ...., value10 }\n dref.setFloatV( dataref_id, start_at, tmp )\n \n Please also read the notes for dref.getFloatV() and dref.getIntV() functions.\n \n dref.setFloatArray(..) does the same things.\n', 'api_dref.cpp#L1197'],
		['dref.setInt', 'dref.setInt( dataref_id, value )', ' Push a new value into a dataref. Value is a decimal number.\n vvi = vvi * 2 \n dref.setFloat( dref_VVI, vvi )\n', 'api_dref.cpp#L1364'],
		['dref.setIntV', 'dref.setIntV( dataref_id, start_at, value1, value2, value3, ... )', ' OR\n tmp = { value1, value2, value3, ...., value10 }\n dref.setIntV( dataref_id, start_at, tmp )\n \n Please also read the notes for dref.getFloatV() and dref.getIntV() functions.\n \n dref.setIntArray(..) does the same things.\n', 'api_dref.cpp#L1287'],
		['dref.setString', 'dref.setString( dataref_id, byte_string_var )', ' \n Eg: dref.setString( dr_id, "This is a new value payload." )\n \n', 'api_dref.cpp#L1149']
		],
	'easings' : [
		['easings.easeOutQuad', 'easings.easeOutQuad( value, target, strength )', '\nReturns: intermediate value based on paramaters.\n\nvalue: current value of user data\ntarget: maximum desired value of user data\nstrength: how fast to get to the user data maximum\n\nAPI: >= 14.04\n', 'easings_api.lua#L15']
		],
	'event' : [
		['event.register', 'event.register( string_event_name, string_callback_function_name )', '\nReturns: nothing.\n\nUse this function to create aliased event hooks.\n\nThis allows you to have multiple "clean" event handler functions.\n \n<code>function OnUpdate_HelloWorld()\n  --Update Hello World secret variables.\nend\n \nevent.register("OnUpdate", "OnUpdate_HelloWorld")\n</code>\nBy using the example above we can create multiple co-existing extensions inside Gizmo64.\nEach extension has full access to the rich Gizmo64 event model.\n \nAPI >= 12.02.01\n', 'api_event.cpp#L17'],
		['event.unregister', 'event.unregister( string_event_name, string_callback_function_name )', '\nReturns: nothing.\n\nUnregister an event hook alias that was previously registered using event.register(...)\n\nUse this function to destroy aliased event hooks.\n\n<code>function OnUpdate_HelloWorld()\n  --Update Hello World secret variables.\nend\n \nevent.register("OnUpdate", "OnUpdate_HelloWorld")\n\n--some time later on...\nevent.unregister("OnUpdate", "OnUpdate_HelloWorld")\n\n</code>\n \nAPI >= 12.02.01\n', 'api_event.cpp#L91']
		],
	'fmc' : [
		['fmc.clear', 'fmc.clear( index_number )', ' Clears the FMC step identified by index_number, eg: 2.\n', 'api_fmc.cpp#L45'],
		['fmc.clearAll', 'fmc.clearAll()', ' Clears all programmed FMC entries.\n \n (Clears 0-99)\n', 'api_fmc.cpp#L29'],
		['fmc.getCount', 'fmc.getCount()', ' Returns: Number of steps programmed into the FMC.\n', 'api_fmc.cpp#L63'],
		['fmc.getDestination', 'fmc.getDestination()', ' Returns: fmc_index_id telling us which leg of the FMC flight plan the pilot has currently selected as the destination.\n', 'api_fmc.cpp#L73'],
		['fmc.getDisplayed', 'fmc.getDisplayed()', ' Returns: fmc_index_id telling us which item the user is currently displaying on the FMC.\n', 'api_fmc.cpp#L86'],
		['fmc.getGpsNavAid', 'fmc.getGpsNavAid()', ' Returns: The current navaid_id that the GPS is programmed for.\n', 'api_fmc.cpp#L110'],
		['fmc.getGpsNavAidType', 'fmc.getGpsNavAidType()', ' Returns: navaid_type value, see nav.api for more.\n', 'api_fmc.cpp#L99'],
		['fmc.getInfo', 'fmc.getInfo( fmc_index_id )', ' Returns: navaid_type, lat, lon, alt, "ICAO_ID", navaid_id\n Eg:\n local fmc_info = { fmc.getInfo( 1 ) }\n \n API: >= 11.9 Changes the order of the returned parameters.\n Old: navaid_type, "ICAO_ID", navaid_id, lat, lon, alt\n New: navaid_type, lat, lon, alt, "ICAO_ID", navaid_id\n \n', 'api_fmc.cpp#L122'],
		['fmc.setDestination', 'fmc.setDestination( fmc_index_id )', ' Controls which leg of the flight plan the FMC will fly towards.\n', 'api_fmc.cpp#L188'],
		['fmc.setDisplayed', 'fmc.setDisplayed( fmc_index_id )', ' Controls which leg of the flight plan is display on the FMC/FMS.\n', 'api_fmc.cpp#L206'],
		['fmc.setInfo', 'fmc.setInfo( fmc_index_id, navaid_id, altitude )', ' Changes an entry in the FMS. The destination coordinates will be updated to those of the navaid_id passed in and the altitude specified.\n Eg:\n Use this only for airports, fixes, and radio-beacon navaids. \n Currently the X-Plane FMC/FMS can only support VORs and NDBs. Use the api functions to fly to a lat/lon.\n', 'api_fmc.cpp#L224'],
		['fmc.setLatLon', 'fmc.setLatLon( fmc_index_id, Latitude, Longitude, altitude )', ' Changes an entry in the FMS. The destination coordinates will be updated to those of the latitude, longitude and altitude specified.\n', 'api_fmc.cpp#L248']
		],
	'font' : [
		['font.drawString', 'font.drawString( font_id, string_to_draw, OPT_x,OPT_y )', ' Returns: nothing\n \n Usage:\n f = font.getFont( xp.getFolder() .. "Courier New.ttf", 36 )\n \n function OnDraw_Windows()\n\tfont.drawString( f, "Lorem ipsum delorem.", 200, 500 )\n end\n\n \nAPI >= 11.12.13 \n \n', 'api_font.cpp#L637'],
		['font.getFont', 'font.getFont( full_path_to_font_file, font_size )', ' Returns: font_id\n \n Usage:\n f = font.getFont( xp.getFolder() .. "Courier New.ttf", 36 )\n\nAPI >= 11.12.13\n', 'api_font.cpp#L566'],
		['font.getStringWidth', 'font.getStringWidth( font_id, string )', ' Returns: horizontal length of string in decimal pixels\n', 'api_font.cpp#L738'],
		['font.measureString', 'font.measureString( font_id, string )', ' Returns: horizontal length of string in decimal pixels\n', 'api_font.cpp#L734']
		],
	'gfx' : [
		['gfx.bakeTerrainMap', 'gfx.bakeTerrainMap( texture_id )', ' Bakes a terrain texture image into the desired texture ID. Drawing is handled by your own code.\n', 'api_gfx.cpp#L1880'],
		['gfx.clearFBO', 'gfx.clearFBO()', ' \n Issues OpenGL commands to clear the current FBO drawing buffers.\n \n See gfx.useFBO(..)\n \n API >= 12.1.2\n \n', 'api_gfx.cpp#L670'],
		['gfx.clearMaskingTape', 'gfx.clearMaskingTape()', '\n This function is useful for drawing gauges.\n See gfx.setMaskingTape(..) for more info.\n', 'api_gfx.cpp#L694'],
		['gfx.clearTexture', 'gfx.clearTexture( texture_id, widht, height, bpp )', ' \n This function will erase an OpenGL texture slot.\n \n width and height should be power of 2 numbers for maximum compatability.\n \n bpp may be either 32 or 24.\n\t32 will upload a black texture with a clear alpha channel to the texture.\n\t24 will upload a black texture with no alpha channel data to the texture.\n \n', 'api_gfx.cpp#L929'],
		['gfx.disableReflectionDrawingCalls', 'gfx.disableReflectionDrawingCalls()', ' Unregister your scripts from X-Planes reflection-drawing calls.\n', 'api_gfx.cpp#L1364'],
		['gfx.drawArc', 'gfx.drawArc( radius, segments, begin_degrees, end_degrees )', ' \n Draws an arc line, use gl.api to setup line styling parameters.\n \n radius in pixels\n segments controls the subdivision level for the arc drawing, higher = smoother.\n begin and end_degrees start at 12\'oclock and wind clockwise.\n \n', 'api_gfx.cpp#L1522'],
		['gfx.drawBox', 'gfx.drawBox( left,bottom,width,height )', '\n Draws a box on the screen, does not fill it.\n Use gl.api to modify line styling params.\n \n', 'api_gfx.cpp#L1618'],
		['gfx.drawCircle', 'gfx.drawCircle( radius,segments )', ' \n Draws a circular line, use gl.api to setup line styling parameters.\n \n radius in pixels\n segments controls the subdivision level for the arc drawing, higher = smoother.\n \n', 'api_gfx.cpp#L1682'],
		['gfx.drawFilledArc', 'gfx.drawFilledArc( radius, segments, begin_degrees, end_degrees )', ' \n Draws an arc line, use gl.api to setup line styling parameters.\n \n radius in pixels\n segments controls the subdivision level for the arc drawing, higher = smoother.\n begin and end_degrees start at 12\'oclock and wind clockwise.\n \n', 'api_gfx.cpp#L1564'],
		['gfx.drawFilledBox', 'gfx.drawFilledBox( left,bottom,width,height )', ' \n Draws a box using raw OpenGL functions.\n Use gfx.setColor( r,g,b, a ) to control color.\n User gfx.texOff() to turn texturing on or off.\n \n', 'api_gfx.cpp#L1808'],
		['gfx.drawFilledCircle', 'gfx.drawFilledCircle( radius,segments )', '\n Draws a filled circle, use gl.api to setup styling parameters.\n \n radius in pixels\n segments controls the subdivision level for the arc drawing, higher = smoother.\n \n', 'api_gfx.cpp#L1720'],
		['gfx.drawLine', 'gfx.drawLine( a,b, x,y )', ' \n Draws a line, use gl.api to setup line styling parameters.\n \n\t--Draw a line from the bottom left corner of the screen/texture\n\t--To approx mid-point. Assuming screen/texture is 1024^2\n \n\tgfx.drawLine( 0,0, 512,512 );\n\n', 'api_gfx.cpp#L1769'],
		['gfx.drawObject', 'gfx.drawObject( object_id, lat,lon,alt, p,r,h )', ' Draw an object in World Coordinates. Lat/Lon/Alt.\n', 'api_gfx.cpp#L2007'],
		['gfx.drawObjectEx', 'gfx.drawObjectEx( object_handle, x,y,z, p,r,h )', ' Draws using X-Planes OBJ8 calls _immediately_, does not force you through Gizmos Queue.\n', 'api_gfx.cpp#L2082'],
		['gfx.drawObjectGL', 'gfx.drawObjectGL( object_handle, x,y,z, p,r,h )', ' Draws using OpenGL coords.\n', 'api_gfx.cpp#L2044'],
		['gfx.drawRadial', 'gfx.drawRadial( heading, radius, length )', '\n Draws a radial line, as used on gauge faces for tick marks, properly rotated to radiate from center.\n', 'api_gfx.cpp#L1842'],
		['gfx.drawString', 'gfx.drawString( string, OPT_x,OPT_y )', '\nReturns: nothing\n\nDraws a string using the default X-Plane font.\nNo other font is available for this function.\n\nx,y parameters are optional, 0,0 is the default if not specified.\nBOTH must be supplied, or none.\n\n<code>\ngfx.drawString( "Hello World!", 512,384 )\n</code>\n\nAPI: >= 12.01\n', 'api_gfx.cpp#L1298'],
		['gfx.drawTexturedQuad', 'gfx.drawTexturedQuad( x,y, w,h )', '\nReturns: nothing\n\nDraws a textured quad. Set the texture before use.\n\nAPI: >= 12.01\n', 'gfx_api.lua#L9'],
		['gfx.drawTranslucentDarkBox', 'gfx.drawTranslucentDarkBox( left,bottom,width,height )', ' \n Draws a transparent dark box using the built in Plugin SDK function: XPLMDrawTranslucentDarkBox(...)\n \n', 'api_gfx.cpp#L1650'],
		['gfx.enableReflectionDrawingCalls', 'gfx.enableReflectionDrawingCalls()', ' Register your scripts with X-Planes reflection-drawing calls.\n This results in your drawing callbacks being called many times.\n', 'api_gfx.cpp#L1376'],
		['gfx.generateTexture_Checkerboard', 'gfx.generateTexture_Checkerboard()', '\nReturns: texture_id\n\nGenerates a 64x64 texture filled with a classic checkerboard pattern.\n\nAPI: >= 12.01\n', 'gfx_api.lua#L37'],
		['gfx.getAircraftPositionGL', 'gfx.getAircraftPositionGL()', 'Returns: x,y,z,p,r,h\nx,y,z,p,r,h = gfx.getAircraftPositionGL()\n', 'api_gfx.cpp#L14'],
		['gfx.getDrawDebugPath', 'gfx.getDrawDebugPath()', 'Returns: true or nil\nCan be used to determine whether to draw additional debug data around the aircraft.\n', 'api_gfx.cpp#L64'],
		['gfx.getFPS', 'gfx.getFPS()', ' Returns: Frames-per-second value, eg: 50.1\n', 'api_gfx.cpp#L105'],
		['gfx.getFrameSpeed', 'gfx.getFrameSpeed( target_speed_per_second )', 'Returns: Distance to move this-frame in OpenGL-space to achieve desired speed per second given.\n', 'api_gfx.cpp#L77'],
		['gfx.getIsViewInsideCockpit', 'gfx.getIsViewInsideCockpit()', ' Returns: boolean\n\n\tBUG FIX: gfx.isViewInsideCockpit() -> gfx.getIsViewInsideCockpit()\n\n \n API: >= 13.06.24\n \n', 'api_gfx.cpp#L331'],
		['gfx.getM', 'gfx.getM()', ' gfx.getFRP()\n Returns: Special multiplier variable^. \n object_speed_for_this_frame = speed_in_meters * gfx.getM() \n \n ^ Data comes from: ( sim/operation/misc/frame_rate_period )\n', 'api_gfx.cpp#L115'],
		['gfx.getScreenSize', 'gfx.getScreenSize()', ' Returns: width,height\n local sw,sh = gfx.getScreenSize()\n', 'api_gfx.cpp#L130'],
		['gfx.getStringWidth', 'gfx.getStringWidth( string )', '\nReturns: horizontal width of string in pixels as float value.\n\n<code>\nlocal width = gfx.measureString( "foo" )\n</code>\n\nAPI: >= 12.01\n', 'api_gfx.cpp#L1484'],
		['gfx.getTexture_CELogo', 'gfx.getTexture_CELogo()', ' Returns: Gizmo Community Edition Texture\n', 'api_gfx.cpp#L205'],
		['gfx.getTexture_GizmoLogo', 'gfx.getTexture_GizmoLogo()', ' Returns: texture_id for Gizmo logo texture.\n', 'api_gfx.cpp#L195'],
		['gfx.getTexture_LiteMap', 'gfx.getTexture_LiteMap()', ' Returns: texture_id for LiteMap texture, not much use with OBJ8 detailed aircraft.\n', 'api_gfx.cpp#L164'],
		['gfx.getTexture_LuaLogo', 'gfx.getTexture_LuaLogo()', ' Returns: texture_id for Lua logo texture.\n', 'api_gfx.cpp#L225'],
		['gfx.getTexture_Paint', 'gfx.getTexture_Paint()', ' Returns: texture_id for Paint texture, not much use with OBJ8 detailed aircraft.\n', 'api_gfx.cpp#L174'],
		['gfx.getTexture_UI', 'gfx.getTexture_UI()', ' Returns: texture_id for X-Plane GUI UI texture. \n Useful to restore state or draw custom widgets.\n', 'api_gfx.cpp#L184'],
		['gfx.getTexture_XALogo', 'gfx.getTexture_XALogo()', ' Returns: texture_id for X-Aviation logo texture.\n', 'api_gfx.cpp#L215'],
		['gfx.loadObject', 'gfx.loadObject( OPT_object_id, filename )', '\nReturns: object_id or nil if object could not be loaded by X-Plane.\n\n<code>\nlocal obj_id = gfx.loadObject( "Aircraft/General Aviation/Cirrus Jet/objects/cockpit.obj" )\n</code>\n\nAPI: >= 13.4.5\n', 'api_gfx.cpp#L426'],
		['gfx.loadPng', 'gfx.loadPng( OPT_texture_id, filename )', '\nReturns: texture_id or -1 if PNG load fails.\n\nLoad a PNG file into the specified texture slot.\n\n<code>\nlocal tex_id = gfx.loadPng( acf.getFolder() .. "texture.png" )\n</code>\n\nAPI: >= 12.01\n', 'api_gfx.cpp#L1054'],
		['gfx.loadTga', 'gfx.loadTga( OPT_texture_id, filename )', '\nReturns: texture_id or -1 if texture load fails.\n\nLoad a TGA file into the specified texture slot. Acceptable formats: 24 or 32 bit. Do not use RLE encoding.\n\n<code>\nlocal tex_id = gfx.loadTga( acf.getFolder() .. "texture.tga" )\n</code>\n\nAPI: >= 12.01\n', 'api_gfx.cpp#L1185'],
		['gfx.loadTgaBlob', 'gfx.loadTgaBlob( texture_id, blob, blob_size )', '\nReturns: 0\n\nThis API is old and rarely used.\n\nLoad a TGA blob into the specified texture slot. Acceptable formats: 24 or 32 bit. Do not use RLE encoding.\n\nThis can be used to download a texture off the disk or bake one in RAM, etc.\n\n<code>\nlocal tga_blob = "bla bla bla binary"\nlocal tex_id = gfx.newTexture()\ngfx.loadTgbBlob( tex_id, tga_blob )\n</code>\n\nAPI: >= 12.01\n', 'api_gfx.cpp#L1255'],
		['gfx.localToWorld', 'gfx.localToWorld( x,y,z )', ' Returns: lat,lon,alt\n Eg:\n lat,lon,alt = gfx.localToWorld( x,y,z )\n', 'api_gfx.cpp#L303'],
		['gfx.matchAircraftOrientation', 'gfx.matchAircraftOrientation()', ' Performs a GL translate and rotate so that your drawing matches the aircraft exactly. \n From here you can easily translate to the nose or a wing tip.\n Note: You MUST wrap this function in calls to gl.PushMatrix() before you call and gl.PopMatrix() after you call. \n If you do not you will corrupt the drawing stack and the result is undefined. Probably junk on screen.\n', 'api_gfx.cpp#L1442'],
		['gfx.measureString', 'gfx.measureString( string )', '\nReturns: horizontal width of string in pixels as float value.\n\n<code>\nlocal width = gfx.measureString( "foo" )\n</code>\n\nAPI: >= 12.01\n', 'api_gfx.cpp#L1473'],
		['gfx.newFBO', 'gfx.newFBO( texture_id, width, height )', ' Returns: fbo_id\n Creates a new Frame-Buffer-Object that can be used to "render to texture".\n See also gfx.useFBO(..) and gfx.releaseFBO(..)\n', 'api_gfx.cpp#L1391'],
		['gfx.newTexture', 'gfx.newTexture()', ' Returns: texture_id\n Creates a blank texture slot that can be used to load a texture into or create an FBO with.\n', 'api_gfx.cpp#L149'],
		['gfx.rebindFBO', 'gfx.rebindFBO( fbo_id..... )', ' BROKEN: gitbug:12\n', 'api_gfx.cpp#L973'],
		['gfx.releaseFBO', 'gfx.releaseFBO( fbo_id )', ' \n Release active FBO and return all drawing targets to normal.\n \n Tweaked to no longer require any FBO argument: 12.12.28\n \n Retweaked to require an FBO argument so we can do mipmap gen.\n \n', 'api_gfx.cpp#L995'],
		['gfx.screenToGL', 'gfx.screenToGL( win_x, win_y )', ' Returns: x,y,z in OpenGL space.\n \n The results you get from this will depend on the callback mode X-Plane is in when you call it.\n \n OnDraw_Windows and OnDraw_Airplanes will return different values because the OpenGL depth buffer contents is different.\n\n * * * EXPERIMENTAL * * *\n \n API: >= 13.10.09.0243\n\n', 'api_gfx.cpp#L240'],
		['gfx.setColor', 'gfx.setColor( r,g,b, a )', ' \n All arguments are 0-1\n Set the color to red, 75% opacity.\n gfx.setColor( 1,0,0, 0.75 )\n \n API >= 12.1\n gfx.setColor( {colors} )\n \n Eg:\n local red = {1,0,0, 1}\n gfx.setColor( red )\n \n', 'api_gfx.cpp#L716'],
		['gfx.setMaskingTape', 'gfx.setMaskingTape( x,y, w,h ) //FIXME: mantis/118', ' \n This function is useful for drawing gauges.\n It will setup a masked region for you to draw inside of.\n All drawing outside of the masked region will be ignored.\n \n (Requests an OpenGL clipping box using glScissor(..))\n \n Many thanks to x-alberto@x-pilot for the code submission.\n http://forums.x-pilot.com/index.php?topic=1502.msg15474#msg15474\n\n \n API: >= 11.5.6\n \n', 'api_gfx.cpp#L584'],
		['gfx.setState', 'gfx.setState( fog, numTexUnits, lighting, alphaTest, alphaBlend, depthTest, depthWrite )', ' Set graphics state using XPLMSetGraphicsState(..) Most flags are 0 or 1.\n numTexUnits accepts > 1\n', 'api_gfx.cpp#L823'],
		['gfx.setTerrainMapMode_Predictive', 'gfx.setTerrainMapMode_Predictive()', ' \n Switch the coloring mode of the terrain map renderer into predictive color rendering.\n', 'api_gfx.cpp#L1903'],
		['gfx.setTerrainMapMode_Relative', 'gfx.setTerrainMapMode_Relative()', ' Switch the coloring mode of the terrain map renderer into relative color rendering.\n', 'api_gfx.cpp#L1914'],
		['gfx.setTerrainMapMode_Synthetic', 'gfx.setTerrainMapMode_Synthetic()', ' Switch the coloring mode of the terrain map renderer into Synthetic color rendering.\n', 'api_gfx.cpp#L1924'],
		['gfx.setTerrainMapMode_Topographic', 'gfx.setTerrainMapMode_Topographic()', ' Switch the coloring mode of the terrain map renderer into FAA topographic color rendering.\n', 'api_gfx.cpp#L1934'],
		['gfx.setTerrainMapOption_LookAhead', 'gfx.setTerrainMapOption_LookAhead( integer_flag )', ' Puts the map into "offset scan" mode, the airframe is approx 1/3 from the bottom edge of the map.\n', 'api_gfx.cpp#L1945'],
		['gfx.setTerrainMapOption_NorthUp', 'gfx.setTerrainMapOption_NorthUp( integer_flag )', ' Locks the map to North-Up mode, you will need to render the users vehicle symbol rotating for the map to make much sense.\n', 'api_gfx.cpp#L1956'],
		['gfx.setTerrainMapOption_Range', 'gfx.setTerrainMapOption_Range( meters_between_sample_points )', ' range * size = scan area.\n', 'api_gfx.cpp#L1967'],
		['gfx.setTerrainMapOption_RefreshRate', 'gfx.setTerrainMapOption_RefreshRate( rate_value )', ' How agressively do we try and build the map data. \n CONFIRM: I think this controls how many scan-lines of the map we try and generate per sim frame.\n The map system is sliced into shards so that low end machines dont "chug" when the map is sampling.\n', 'api_gfx.cpp#L1978'],
		['gfx.setTerrainMapOption_Size', 'gfx.setTerrainMapOption_Size( number_of_samples_along_an_edge )', ' scan area for the map = size * range\n This directly affects the OpenGL texture size. Default is 128. \n Valid values: 32,64,128,256,512,1024 etc\n Map texture is sampled and rendered "square".\n', 'api_gfx.cpp#L1992'],
		['gfx.texOff', 'gfx.texOff()', ' Turn OpenGL texturing off.\n', 'api_gfx.cpp#L855'],
		['gfx.texOn', 'gfx.texOn()', ' Turn OpenGL texturing on.\n', 'api_gfx.cpp#L876'],
		['gfx.useFBO', 'gfx.useFBO( fbo_id )', ' Makes an FBO object active and redirects all OpenGL drawing into that FBO. \n All drawing will be saved into the texture nominated during gfx.newFBO(..) \n You MUST call gfx.releaseFBO() when you are finished drawing.\n', 'api_gfx.cpp#L897'],
		['gfx.useTexture', 'gfx.useTexture( texture_id )', ' Sets your nominated texture as "active" for OpenGL drawing operations.\n', 'api_gfx.cpp#L1037'],
		['gfx.worldToLocal', 'gfx.worldToLocal( lat,lon,alt )', ' Convert world-space coordinates, from a real map, into OpenGL drawing coordinates, for use in a Game Engine.\n This function makes no attempt to check if your request makes sense, if you ask for coordinates on the other side of the planet the result is undefined. Good luck.\n x,y,z = gfx.worldToLocal( lat,lon,alt )\n', 'api_gfx.cpp#L2136']
		],
	'gizmo' : [
		['gizmo.dofile', 'gizmo.dofile( filename )', '\nReturns: nothing\n\nBasically the same as the built in Lua dofile() except we work with encrypted files.\n\n<code>\ngizmo.dofile("secured.lua.aes")\n</code>\n\nAPI >= 11.11.03\n', 'api_gizmo.cpp#L239'],
		['gizmo.dofirmware', 'gizmo.dofirmware( filename )', '\nReturns: nothing\n\nBasically the same as the built in Lua dofile() except we work with encrypted files inside the firmware folder.\n\nWARNING: \nThis is NOT interchangable with gizmo.dofile.\nEncryption key is different.\n\n<code>\ngizmo.dofirmware( "firmware_ext.lua.aes" )\n</code>\n\nAPI >= 12.01.29\n', 'api_gizmo.cpp#L193'],
		['gizmo.getBuildDate', 'gizmo.getBuildDate()', ' Returns: String containing date that the .xpl file was compiled.\n Eg:\n date_built = gizmo.getBuildDate()\n', 'api_gizmo.cpp#L409'],
		['gizmo.getDisabledEventNames', 'gizmo.getDisabledEventNames()', ' Returns: Table of strings containing all disabled event names.\n Eg:\n disabled_events = { gizmo.getDisabledEventNames() }\n', 'api_event.cpp#L142'],
		['gizmo.getFolder', 'gizmo.getFolder()', '\nReturns: string\n\nGet the folder for Gizmo64 and all its resources.\n\nAPI: >= 14.04\n', 'gizmo_api.lua#L10'],
		['gizmo.getPossibleEventNames', 'gizmo.getPossibleEventNames()', ' Returns: Table of strings containing all possible event names.\n Eg:\n possible_events = { gizmo.getPossibleEventNames() }\n', 'api_event.cpp#L175'],
		['gizmo.getVersion', 'gizmo.getVersion()', ' Returns: "Human" friendly version string.\n', 'api_gizmo.cpp#L571'],
		['gizmo.getVersionFull', 'gizmo.getVersionFull()', ' Returns: Machine friendly version number as Integer.\n Eg: 201103141234 - 2011-03-14-1234\n', 'api_gizmo.cpp#L583'],
		['gizmo.reboot', 'gizmo.reboot()', ' Reboot the Gizmo script engine, same effect as the menu item.\n', 'api_gizmo.cpp#L596'],
		['gizmo.resetEventMap', 'gizmo.resetEventMap()', ' Reset the table of disabled events. Causes all events to be allowed another try.\n', 'api_event.cpp#L128'],
		['gizmo.resetFirmware', 'gizmo.resetFirmware()', ' Reset the firmware to a copy from disk.\n (Gizmo64.plugin/scripts/firmware.lua)\n', 'api_gizmo.cpp#L473'],
		['gizmo.setCommunityEdition', 'gizmo.setCommunityEdition( flag )', '\nDisplays the CE banner.\n\nAPI: >= 13.10.21\n\n', 'api_gizmo.cpp#L431'],
		['gizmo.setDebugVerbose', 'gizmo.setDebugVerbose( flag )', ' Increase debugging messages that get in your face with dialog boxes etc.\n Good for development, not so good for shipping products sometimes.\n', 'api_gizmo.cpp#L450'],
		['gizmo.sleep', 'gizmo.sleep( duration_in_milliseconds, OPT_power_saver )', '\nReturns: nothing\n\nCauses the main X-Plane thread to sleep for N ms.\n\nPassing a second argument sets the Gizmo "Global Power Saver" sleep value.\nThis value is NOT reset automatically when Gizmo reboots the script engine.\nThis option is intended for developers and those wanting greater control over X-Planes CPU priority.\n\n<code>\n--Make x-plane sleepy, low power consumption, better OS response.\n--This will make x-plane sleep for 20ms every flight loop.\ngizmo.sleep( 20, 1 )\n\n--remove sleep delay\ngizmo.sleep( 0, 0 )\n\n--Sleep for 10ms, once only.\ngizmo.sleep( 10 )\n</code>\n\nAPI: >= 11.11 for gizmo.sleep(duration, power_saver)\n', 'api_gizmo.cpp#L490']
		],
	'gl' : [
		['gl.read_me', 'gl.read_me()', '\n Gizmo provides access to LuaGL, a Lua binding for OpenGL.\n This provides access to any GL commands you want to execute.\n \n You are not constrained by only what\'s in the gfx.api.\n \n http://luagl.sourceforge.net/#ref\n \n', 'api_third_party_docs.cpp#L50']
		],
	'glu' : [
		['glu.read_me', 'glu.read_me()', ' \n Gizmo provides access to LuaGL, a Lua binding for OpenGL.\n This provides access to any GL commands you want to execute.\n \n You are not constrained by only what\'s in the gfx.api.\n \n http://luagl.sourceforge.net/#ref\n \n API: >= 11.5.25\n \n', 'api_third_party_docs.cpp#L63']
		],
	'gui' : [
		['gui.blur', 'gui.blur( gui_widget_id )', ' \n Removes keyboard focus.\n \n API: >= 11.8.2\n', 'api_gui.cpp#L15'],
		['gui.getCustomWidgetMouseXY', 'gui.getCustomWidgetMouseXY( )', ' Returns: x,y for mouse corrected for use in Custom Widget graphics.\n \n API: > 11.5.15\n', 'api_gui.cpp#L153'],
		['gui.getWidgetSize', 'gui.getWidgetSize( gui_widget_id )', ' \n Returns: left,top,width,height\n \n API: >= 11.5.29\n', 'api_gui.cpp#L230'],
		['gui.getWidgetValue', 'gui.getWidgetValue( gui_widget_id )', ' Returns: value of gui_widget_id\n \n Basic functionality available since 11.1\n \n Enhanced in >= 11.9\n \n Returns: boolean for checkbox or radio-button widgets, text value for others.\n', 'api_gui.cpp#L173'],
		['gui.getWindowList', 'gui.getWindowList()', ' Returns: table of strings containing the names of all GUI Windows Gizmo is managing.\n window_list = { gui.getWindowList() }\n', 'api_gui.cpp#L397'],
		['gui.getWindowSize', 'gui.getWindowSize( gui_window_id )', ' \n Returns: left,top,width,height\n \n API: >= 11.5.29\n', 'api_gui.cpp#L254'],
		['gui.hideWidget', 'gui.hideWidget( gui_widget_id )', '\nReturns: nothing\n\nHides a GUI Widget.\n\n<code>\ngui.hideWidget( widget_txtBox )\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L419'],
		['gui.hideWindow', 'gui.hideWindow( gui_window_id )', '\nReturns: nothing\n\nHides a GUI Window.\n\n<code>\ngui.hideWindow( window_foo )\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L446'],
		['gui.newButton', 'gui.newButton( gui_window_id, click_handler_function_name_string, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\nWhen clicked the function MyClickHandlerFunction_OnClick() will be called.\n\n<code>\nlocal widget = gui.newButton( window, "MyClicker", "GO!", 10, 10, 100 )\n\nfunction MyClicker_OnClick()\n\tsound.say("button was clicked")\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L775'],
		['gui.newCheckbox', 'gui.newCheckbox( gui_window_id, click_handler_function_string, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\nWhen clicked the function MyClickHandlerFunction_OnClick() will be called.\n\nWhen using a checkbox the caption will display poorly.\nIt\'s recommended that you use a seperate text-label widget.\n\n<code>\nlocal widget = gui.newCheckbox( window, "MyClicker", "GO!", 10, 10, 100 )\n\nfunction MyClicker_OnClick()\n\tsound.say("button was clicked")\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L858'],
		['gui.newCustomWidget', 'gui.newCustomWidget( gui_window_id, event_handler_function, left, top, width, height )', '\nReturns: gui_widget_id\n\n<code>\nlocal widget_id = gui.newCustomWidget( gui_window_id, "EventHandlerFunction", left, top, width, height )\n\nfunction EventHandlerFunction_OnDraw()\n\t--Do stuff.\n\t--You MUST draw here.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L945'],
		['gui.newLabel', 'gui.newLabel( gui_window_id, event_handler_function, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\n<code>\nlocal label = gui.newLabel( gui_window_id, "EventHandlerFunction", "Button Caption", left, top, width )\n\nfunction EventHandlerFunction_OnClick()\n\t--Label was clicked.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1064'],
		['gui.newListView', 'gui.newListView( gui_window_id, event_handler_function, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\n<code>\nlocal label = gui.newListView( gui_window_id, "EventHandlerFunction", "Button Caption", left, top, width )\n\nfunction EventHandlerFunction_OnClick()\n\t--Label was clicked.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1146'],
		['gui.newPasswordBox', 'gui.newPasswordBox( gui_window_id, event_handler_function, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\n<code>\nlocal label = gui.newPasswordBox( gui_window_id, "EventHandlerFunction", "Button Caption", left, top, width )\n\nfunction EventHandlerFunction_OnClick()\n\t--Label was clicked.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1535'],
		['gui.newScreen', 'gui.newScreen( gui_window_id, event_handler_function, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\nFIXME: I think this is for some kind of SDK-named sub-window. The naming sucks. Totally ambiguous/confusing.\n\n<code>\nlocal label = gui.newScreen( gui_window_id, "EventHandlerFunction", "Button Caption", left, top, width )\n\nfunction EventHandlerFunction_OnClick()\n\t--Label was clicked.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1381'],
		['gui.newSubWindow', 'gui.newSubWindow( gui_window_id, event_handler_function, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\n<code>\nlocal label = gui.newSubWindow( gui_window_id, "EventHandlerFunction", "Button Caption", left, top, width )\n\nfunction EventHandlerFunction_OnClick()\n\t--Label was clicked.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1304'],
		['gui.newTextBox', 'gui.newTextBox( gui_window_id, event_handler_function, button_caption, left, top, width )', '\nReturns: gui_widget_id\n\n<code>\nlocal label = gui.newTextBox( gui_window_id, "EventHandlerFunction", "Button Caption", left, top, width )\n\nfunction EventHandlerFunction_OnClick()\n\t--Label was clicked.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1460'],
		['gui.newWindow', 'gui.newWindow( window_name )', '\nReturns: gui_window_id\n\nGizmo will look for and automatically call WindowIdentifier_OnCreate() to allow defered and somewhat neater code\nfor creating the actual window layout.\n\n<code>\nlocal window = gui.newWindow( "MyWindow" )\n\nfunction MyWindow_OnCreate()\n\tlocal txtBox = gui.newTextBox( window, ... ) --see docs for gui.newTextBox\nend\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L1620'],
		['gui.setCustomWidgetClipping', 'gui.setCustomWidgetClipping( gui_widget_id, integer_bool_flag )', '\nReturns: nothing\n\nSets GL clipping on/off for custom widget bounds.\n\n<code>\n--clipping off\ngui.setCustomWidgetClipping( widget_id, 0 )\n\n--clipping on\ngui.setCustomWidgetClipping( widget_id, 1 )\n</code>\n\nAPI: >= 11.11\n', 'api_gui.cpp#L43'],
		['gui.setFocus', 'gui.setFocus( gui_widget_id )', '\n Set keyboard focus.\n \n API: >= 11.8.2\n', 'api_gui.cpp#L80'],
		['gui.setPasswordMode', 'gui.setPasswordMode( gui_widget_id, int_flag )', ' Control the password-hiding mode of a text field.\n', 'api_gui.cpp#L312'],
		['gui.setWidgetSelection', 'gui.setWidgetSelection( gui_widget_id, selection_start, selection_end )', ' Returns: nil\n \n Used to control the selection range of things like text boxes.\n \n If used during an _OnKeyDown handler you will need to use a deferred execution in some circumstances.\n \n \n API: >= 14.03.13\n', 'api_gui.cpp#L515'],
		['gui.setWidgetSize', 'gui.setWidgetSize( gui_widget_id, left, top, width, height )', ' \n API: >= 11.5.29\n', 'api_gui.cpp#L590'],
		['gui.setWidgetValue', 'gui.setWidgetValue( gui_widget_id, new_value )', '\nReturns: nothing\n\nSets the value of the target widget to the value you pass in.\nValues can be strings or numbers, other data will probably fail.\n\nBasic functionality available since 11.1\n\nEnhanced in >= 11.9\n\nNow accepts 0/1 for checkbox or radio-button widgets to modify their state.\n\n<code>\ngui.setWidgetValue( widget_txtUsername, "br@x-plugins.com" )\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L339'],
		['gui.setWindowCaption', 'gui.setWindowCaption( gui_window_id, window_caption )', '\nReturns: nothing\n\n<code>\ngui.setWindowCaption( window_h, "Window Title Bar Caption" )\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L473'],
		['gui.setWindowSize', 'gui.setWindowSize( gui_window_id, left, top, width, height )', '\nReturns: nothing\n\nSet the window size for a GUI Window.\n\n<code>\ngui.setWindowSize( window_foo, 10,10, 640,480)\n</code>\n\nAPI: >= 12.01\n', 'api_gui.cpp#L685'],
		['gui.showWidget', 'gui.showWidget( gui_widget_id )', ' Show target Widget.\n', 'api_gui.cpp#L734'],
		['gui.showWindow', 'gui.showWindow( gui_window_id )', ' Show target Window.\n', 'api_gui.cpp#L751']
		],
	'gxt' : [
		['gxt.autoload', 'gxt.autoload()', '\nReturns: nothing\n\nInternal function.\n\nLoads all extensions that are setup for auto loading.\n\nAPI: >= 14.04\n', 'gxt_api.lua#L521'],
		['gxt.getListIdByName', 'gxt.getListIdByName( extensionName )', '\nReturns: gxt.list index\n\nUsed to query the GXT data.\n\nAPI: >= 14.04\n', 'gxt_api.lua#L177'],
		['gxt.getLoaded', 'gxt.getLoaded( extensionName )', '\nReturns: boolean\n\nTrue if GXT has already been loaded.\n\nAPI: >= 14.04\n', 'gxt_api.lua#L207'],
		['gxt.load', 'gxt.load( extension_name )', '\nReturns: nothing.\n\nAttempts to load the named Gizmo64 Firmware Extension.\n\nThe GXT API module will look for the folder:\nX-Plane/Resources/plugins/Gizmo64.plugin/firmware/extensions/extension_name\nand attempt to load any valid extension content that it finds.\n\n<code>gxt.load("Notepad")</code>\n\nAPI: >= 14.04\n', 'gxt_api.lua#L304'],
		['gxt.refresh', 'gxt.refresh()', '\nReturns: nothing\n\nRebuilds the list of gxt modules found in Gizmo64.plugin/firmware/extensions/\n\n<code>\ngxt.refresh()\n</code>\n\nAPI: >= 14.04\n', 'gxt_api.lua#L36'],
		['gxt.sendMessage', 'gxt.sendMessage( extensionName, message, param )', '\nReturns: nothing\n\nAllows for mediation between modules.\n\nWill allow you to send a message to an extension that hasn\'t been loaded yet.\n\nWill autoload an extension if required.\n\n<code>\ngxt.sendMessage( "TextureExplorer", "Load", "foo.png" )\n</code>\n\nAPI: >= 14.04\n', 'gxt_api.lua#L454'],
		['gxt.setLoaded', 'gxt.setLoaded( extensionName, bool_loaded )', '\nReturns: nothing\n\nInternal function, sets loaded state for a GXT by name.\n\nAPI: >= 14.04\n', 'gxt_api.lua#L231'],
		['gxt.show', 'gxt.show( extensionName )', '\nReturns: nothing\n\nUsed to show a GXT GUI.\n\nCalls GXT _OnShow() function.\n\nWill automatically load a GXT using gxt.load(...) if required.\n\n<code>\ngxt.show( "Notepad" )\n</code>\n\nAPI: >= 14.04\n', 'gxt_api.lua#L251'],
		['gxt.unload', 'gxt.unload( extension_name )', '\nReturns: nothing.\n\nAttempts to unload the named Gizmo64 Firmware Extension.\n\nThe GXT API will call function: extension_name_OnBeforeUnload() to give the target an opportunity to unload cleanly.\n\n<code>gxt.unload("Notepad")</code>\n\nAPI: >= 14.04\n', 'gxt_api.lua#L373']
		],
	'hash' : [
		['hash.md5File', 'hash.md5File( filename )', '\nReturns: string containing md5 hash of file.\n\nAPI: >= 12.01\n', 'api_hash.cpp#L14'],
		['hash.md5String', 'hash.md5String( input_string_blob )', '\nReturns: string containing md5 hash of file.\n\nAPI: >= 12.01\n', 'api_hash.cpp#L51']
		],
	'http' : [
		['http.get', 'http.get( url, callback_function_name )', ' Eg:\n function cb_http_get_complete( data, url, size )\n sound.say(\'dl complete: \' .. url)\n end\n \n url = \'http://example.com/foo.htm\'\n sound.say( \'fetch: \' .. url )\n http.get( url, \'cb_http_get_complete\' )\n', 'api_http.cpp#L16'],
		['http.post', 'http.post( url, callback_function_name, post_payload )', ' Eg:\n payload = string.format( "status=%s", http.urlEncode("this is a status update") ) \n \n See HTTP POST format details for more info. \n It\'s like a query string but the content isn\'t auto encoded by a browser.\n', 'api_http.cpp#L104'],
		['http.resetProxy', 'http.resetProxy()', ' Resets internal proxy variables. cURL library will default to using ENV variables if any or no proxy at all.\n', 'api_http.cpp#L234'],
		['http.setProxy', 'http.setProxy( proxy_url )', '\nReturns: nothing\n\nSend a blank string to force use of no proxy for all connections.\nUse http.resetProxy() to reset to default.\n\n<code>\n--Set the proxy:\nhttp.setProxy( "http://user:pass@proxy.host.lan:8001/" )\n\n--Clear the proxy:\nhttp.setProxy( "" )\n</code>\n\nAPI: >= 12.01\n', 'api_http.cpp#L251'],
		['http.urlDecode', 'http.urlDecode( data, data_length )', ' Returns: url-decoded string\n See http.urlEncode for usage example.\n', 'api_http.cpp#L209'],
		['http.urlEncode', 'http.urlEncode( data, data_length )', ' Returns: url-encoded string\n Eg:\n s = "raw string data to send."\n e = http.urlEncode( s, #s )\n http.post(url, cb_function, "data=" .. e)\n', 'api_http.cpp#L182']
		],
	'icons' : [
		['icons.get', 'icons.get( icon_name, OPT_no_cache )', '\nReturns: texture_id\n\nLoad an icon from Gizmo64.plugin/firmware/icons/\n\nActs as a common gateway to shared icon resources, provides caching so that we load a minimal set of texture copies.\n\nSet no_cache to True if you require a unique copy of the icon texture.\n\n<code>\nlocal icon_save = icons.get("save.png")\n</code>\n\nAPI: >= 14.04\n', 'icons_api.lua#L18']
		],
	'io' : [
		['io.read_me', 'io.read_me()', '\nGizmo exposes a sandboxed set of Lua Stadnard "io" library functions.\nSee the Lua programming references available via Google for more information.\n\nIO Operations are "Sandboxed" inside the X-Plane folder.\nYou may access any file _inside_ the X-Plane folder.\n\nThe sandbox applies to the following functions:\nio.open, os.remove, os.rename\n\nAll other functions behave as documented in Lua manuals.\n\nhttp://www.lua.org/manual/5.2/manual.html#6.8\n\n', 'api_third_party_docs.cpp#L86']
		],
	'logging' : [
		['logging.clear', 'logging.clear()', '\nReturns: nothing\n\nClear the log records.\n\nAPI: >= 12.01\n', 'api_logging.cpp#L15'],
		['logging.debug', 'logging.debug( message )', '\nReturns: nothing\n\nThis function writes a message to the X-Plane Log.txt file.\n\nAPI: >= 12.2.1\n', 'api_logging.cpp#L35'],
		['logging.error', 'logging.error( message )', '\nReturns: nothing\n\nThis function writes a message to the X-Plane Log.txt file.\n\nAPI: >= 12.2.1\n', 'api_logging.cpp#L66'],
		['logging.getMessages', 'logging.getMessages()', '\nReturns: table containing all logged messages.\n\nAPI: >= 12.2.1\n', 'api_logging.cpp#L138'],
		['logging.warning', 'logging.warning( message )', '\nReturns: nothing\n\nThis function writes a message to the X-Plane Log.txt file.\n\nAPI: >= 12.2.1\n', 'api_logging.cpp#L100']
		],
	'map' : [
		['map.bake', 'map.bake( map_id, texture_id )', ' Returns: nothing\n \n API: >= broken\n \n', 'api_map.cpp#L83'],
		['map.newMap', 'map.newMap()', ' Returns: map_id\n \n API: >= broken\n \n', 'api_map.cpp#L14'],
		['map.setColorMode', 'map.setColorMode( map_id, map.color_mode )', ' Returns: nothing\n \n See color modes for availanle options.\n \n API: >= broken\n \n', 'api_map.cpp#L48'],
		['map.setLookAhead', 'map.setLookAhead( map_id, look_ahead )', ' Returns: nothing\n \n API: >= broken\n \n', 'api_map.cpp#L61'],
		['map.setNorthUp', 'map.setNorthUp( map_id, north_up )', ' Returns: nothing\n \n API: >= broken\n', 'api_map.cpp#L72'],
		['map.setPosition', 'map.setPosition( map_id, lat, lon, alt_agl, heading )', ' Returns: nothing\n \n API: >= broken\n \n', 'api_map.cpp#L25'],
		['map.setRange', 'map.setRange( map_id, range )', ' Returns: nothing\n \n API: >= broken\n \n', 'api_map.cpp#L36']
		],
	'math' : [
		['math.abs', 'math.abs(x)', '\nReturns: the absolute value of x.\n', 'api_third_party_docs.cpp#L114'],
		['math.acos', 'math.acos(x)', '\nReturns: the arc cosine of x (in radians).\n', 'api_third_party_docs.cpp#L120'],
		['math.asin', 'math.asin(x)', '\nReturns the arc sine of x (in radians).\n', 'api_third_party_docs.cpp#L126'],
		['math.atan', 'math.atan(x)', '\nReturns the arc tangent of x (in radians).\n', 'api_third_party_docs.cpp#L132'],
		['math.atan2', 'math.atan2(y, x)', '\nReturns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)\n', 'api_third_party_docs.cpp#L138'],
		['math.ceil', 'math.ceil(x)', '\nReturns the smallest integer larger than or equal to x.\n', 'api_third_party_docs.cpp#L144'],
		['math.cos', 'math.cos(x)', '\nReturns the cosine of x (assumed to be in radians).\n', 'api_third_party_docs.cpp#L150'],
		['math.cosh', 'math.cosh(x)', '\nReturns the hyperbolic cosine of x.\n', 'api_third_party_docs.cpp#L156'],
		['math.deg', 'math.deg(x)', '\nReturns the angle x (given in radians) in degrees.\n', 'api_third_party_docs.cpp#L162'],
		['math.exp', 'math.exp(x)', '\nReturns the value ex.\n', 'api_third_party_docs.cpp#L168'],
		['math.floor', 'math.floor(x)', '\nReturns the largest integer smaller than or equal to x.\n', 'api_third_party_docs.cpp#L174'],
		['math.fmod', 'math.fmod(x, y)', '\nReturns the remainder of the division of x by y that rounds the quotient towards zero.\n', 'api_third_party_docs.cpp#L180'],
		['math.frexp', 'math.frexp(x)', '\nReturns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).\n', 'api_third_party_docs.cpp#L186'],
		['math.huge', 'math.huge', '\nThe value HUGE_VAL, a value larger than or equal to any other numerical value.\n', 'api_third_party_docs.cpp#L192'],
		['math.ldexp', 'math.ldexp(m, e)', '\nReturns m2e (e should be an integer).\n', 'api_third_party_docs.cpp#L198'],
		['math.log', 'math.log(x)', '\nReturns the natural logarithm of x.\n', 'api_third_party_docs.cpp#L204'],
		['math.log10', 'math.log10(x)', '\nReturns the base-10 logarithm of x.\n', 'api_third_party_docs.cpp#L210'],
		['math.max', 'math.max(x, ...)', '\nReturns the maximum value among its arguments.\n', 'api_third_party_docs.cpp#L216'],
		['math.min', 'math.min(x, ...)', '\nReturns the minimum value among its arguments.\n', 'api_third_party_docs.cpp#L222'],
		['math.modf', 'math.modf(x)', '\nReturns two numbers, the integral part of x and the fractional part of x.\n', 'api_third_party_docs.cpp#L228'],
		['math.pi', 'math.pi', '\nThe value of pi.\n', 'api_third_party_docs.cpp#L234'],
		['math.pow', 'math.pow(x, y)', '\nReturns xy. (You can also use the expression x^y to compute this value.)\n', 'api_third_party_docs.cpp#L240'],
		['math.rad', 'math.rad(x)', '\nReturns the angle x (given in degrees) in radians.\n', 'api_third_party_docs.cpp#L246'],
		['math.random', 'math.random(OPT_m, OPT_n)', '\nReturns: random float\n\nThis function is an interface to the simple pseudo-random generator function rand provided by ANSI C. \n(No guarantees can be given for its statistical properties.)\n\nWhen called without arguments, returns a uniform pseudo-random real number in the range [0,1). \nWhen called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. \nWhen called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n].\n\nAPI: >= 12.01\n', 'api_third_party_docs.cpp#L252'],
		['math.randomseed', 'math.randomseed(x)', '\nSets x as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers.\n', 'api_third_party_docs.cpp#L267'],
		['math.sin', 'math.sin(x)', '\nReturns the sine of x (assumed to be in radians).\n', 'api_third_party_docs.cpp#L273'],
		['math.sinh', 'math.sinh(x)', '\nReturns the hyperbolic sine of x.\n', 'api_third_party_docs.cpp#L279'],
		['math.sqrt', 'math.sqrt(x)', '\nReturns the square root of x. (You can also use the expression x^0.5 to compute this value.)\n', 'api_third_party_docs.cpp#L285'],
		['math.tan', 'math.tan(x)', '\nReturns the tangent of x (assumed to be in radians).\n', 'api_third_party_docs.cpp#L291'],
		['math.tanh', 'math.tanh(x)', '\nReturns the hyperbolic tangent of x.\n', 'api_third_party_docs.cpp#L297']
		],
	'matrix' : [
		['matrix.angleToVector', 'matrix.angleToVector( angle )', '\nReturns: table[3]\n\nConverts an angle into a vector.\n\n<code>\nlocal vec = matrix.angleToVector( 45 )\n</code>\n\nAPI: >= 14.04\n', 'matrix_api.lua#L13'],
		['matrix.transform3D', 'matrix.transform3D( x,y,z,  tx,ty,tz,  tp,tr,th )', ' Returns: transformed_x, transformed_y, transformed_z\n \n This function can be used to apply a 3D transformation to a position vector.\n\n Submitted by x-alberto?\n \n\n API: >= 11.4\n \n', 'api_matrix.cpp#L14']
		],
	'memcache' : [
		['memcache.get', 'memcache.get( key_name )', '\nReturns: String containing value stored in key, or nil.\n\nAPI: >= 10.11.22\n', 'api_memcache.cpp#L26'],
		['memcache.set', 'memcache.set( key_name, string_blob )', '\nReturns: nothing\n\nOverwrites the value at "key name" with string_blob.\n\nAPI: >= 10.11.22\n', 'api_memcache.cpp#L64']
		],
	'menu' : [
		['menu.newItem', 'menu.newItem( menu_label, menu_event_name )', '\nReturns: true or nothing\n\nMenu will be created at: Plugins > Gizmo > Scripts > "Menu Label"\nWhen clicked Gizmo will call the function: MenuEventName_OnClick()\n\n<code>\nmenu.newItem("My Menu Item", "MyMenuEvent")\n\nfunction MyMenuEvent_OnClick()\n\t--menu was clicked\nend\n</code>\n\nAPI: >= 10.11.22\n', 'api_menu.cpp#L17']
		],
	'mouse' : [
		['mouse.getXY', 'mouse.getXY()', ' Returns: Mouse X,Y location on the screen. \n\t\n Eg: \n\tm.x,m.y = mouse.getXY()\n \n', 'api_mouse.cpp#L62'],
		['mouse.getXYZ', 'mouse.getXYZ()', ' Returns: x,y,z in OpenGL space.\n \n The results you get from this will depend on the callback mode X-Plane is in when you call it.\n \n OnDraw_Windows and OnDraw_Airplanes will return different values because the OpenGL depth buffer contents is different.\n\n * * * EXPERIMENTAL * * *\n \n API: >= 13.10.08.2340\n\n', 'api_mouse.cpp#L88'],
		['mouse.setCursor', 'mouse.setCursor( cursor_drawing_function_name )', '\nReturns: nothing\n<code>\n--set cursor to custom GL function\nmouse.setCursor( "drawCustomCursor" )\n\nfunction drawCustomCursor()\n\t--mouse.x and mouse.y are automatically updated by Gizmo64.plugin\n\tgfx.drawString("mouse cursor", mouse.x, mouse.y)\nend\n</code>\n\n<code>\n--reset the mouse cursor to default\nmouse.setCursor("")\n</code>\n\nAPI: >= 12.01\n', 'api_mouse.cpp#L14']
		],
	'nav' : [
		['nav.findNavAid', 'nav.findNavAid( name, id, lat, lon, frequency )', '\nReturns: navaid_id\n\nCombine with nav.setSearchGroups(...)\nThis function can be used to search the nav database.\n\nBy setting "name" or "id" to "*" you can create a wild-card search.\nBy setting "name" or "id" to nil you can create a wild-card search.\n\nAPI: >= 12.01\n', 'api_nav.cpp#L54'],
		['nav.getFirstNavAid', 'nav.getFirstNavAid()', ' Returns: First navaid_id in the database.\n', 'api_nav.cpp#L301'],
		['nav.getFirstNavAidOfType', 'nav.getFirstNavAidOfType( navaid_type )', ' Returns: First navaid_id available that matches the specified type.\n', 'api_nav.cpp#L311'],
		['nav.getLastNavAidOfType', 'nav.getLastNavAidOfType( navaid_type )', ' Returns: Last navaid_id available that matches the specified type.\n', 'api_nav.cpp#L326'],
		['nav.getNavAidInfo', 'nav.getNavAidInfo( navaid_id )', ' Returns: navaid_type, lat, lon, alt, "ICAO_ID", "Name", reg, freq, heading\n \n Here is some little known info about "getNavAidInfo"...\n Returning frequency for a type of xplm_Nav_Airport is not supported.\n It is also not supported for a type of xplm_Nav_Fix.\n \n Using all other types will return the frequency.\n This is because this info is in the nav database and not the apt or fix databases\n \n API: >= 11.9 Changes the order of the returned parameters.\n Old: navaid_type, lat, lon, alt, freq, heading, "ICAO_ID", "Name", reg\n New: navaid_type, lat, lon, alt, "ICAO_ID", "Name", reg, freq, heading\n', 'api_nav.cpp#L342'],
		['nav.getNextNavAid', 'nav.getNextNavAid( nav_ref )', ' Returns: Next navaid_id available that matches the specified type.\n', 'api_nav.cpp#L424'],
		['nav.getTypeName', 'nav.getTypeName( navaid_type )', ' Returns: String representation of nav-aid type, see predefined var list at start of this API chapter for basic info.\n \n Eg:\n x = nav.airport\n name = nav.getTypeName( x )\n print(name)\n -- name is now == "airport"\n \n \n navaid_types:\n The following variables are automatically defined by Gizmo.\n \n nav.unknown\n nav.airport\n nav.ndb\n nav.vor\n nav.ils\n nav.localizer\n nav.glideslope\n nav.outermarker\n nav.middlemarker\n nav.innermarker\n nav.fix\n nav.dme\n nav.latlon\n \n API: >= 11.1(?)\n \n \n nav.not_found -- added as mapping for XPLM_NAV_NOT_FOUND from C SDK.\n See: http://www.xsquawkbox.net/xpsdk/mediawiki/XPLMNavRef\n \n API: >= 11.9.8\n \n', 'api_nav.cpp#L188'],
		['nav.setSearchGroups', 'nav.setSearchGroups( airports, ndbs, vors, ils, localizers, glideslopes, outermarkers, middle_markers, innermarkers, fixes, dmes, latlons )', ' \n Pass a 0 or 1 in for each option value.\n Combine this with nav.findNavAid()\n \n nav.setSearchGroups( 1,1,1,1, 0,0,0,0, 1,1,1,1 )\n', 'api_nav.cpp#L440'],
		['navaid_types:', 'navaid_types:', ' The following variables are automatically defined by Gizmo.\n \n nav.unknown\n nav.airport\n nav.ndb\n nav.vor\n nav.ils\n nav.localizer\n nav.glideslope\n nav.outermarker\n nav.middlemarker\n nav.innermarker\n nav.fix\n nav.dme\n nav.latlon\n \n API: >= 11.1(?)\n \n \n nav.not_found -- added as mapping for XPLM_NAV_NOT_FOUND from C SDK.\n See: http://www.xsquawkbox.net/xpsdk/mediawiki/XPLMNavRef\n\n API: >= 11.9.8\n \n \n', 'api_nav.cpp#L24']
		],
	'os' : [
		['os.read_me', 'os.read_me()', '\nThe following functions are disabled in Gizmo64:\nos.execute, os.tmpname, os.exit, io.popen\n \nThis is to prevent malicious scripts from causing annoyance on the users computer.\n\nAll other os functions are available as documented in Lua manuals.\n\nhttp://www.lua.org/manual/5.2/manual.html#6.9\n\n', 'api_third_party_docs.cpp#L313']
		],
	'package' : [
		['package.read_me', 'package.read_me()', '\nGizmo64 provides the full Lua package.api\n \nhttp://www.lua.org/manual/5.2/manual.html#6.3\n \n', 'api_third_party_docs.cpp#L335']
		],
	'particles' : [
		['particles.newParticles', 'particles.newParticles()', ' Returns: particles_id - handle for particle engine, useful in other particles.api functions.\n', 'api_particles.cpp#L21'],
		['particles.setBirthRate', 'particles.setBirthRate( particle_emitter_id, particles_per_second )', '', 'api_particles.cpp#L45'],
		['particles.setBounce', 'particles.setBounce( particle_emitter_id, int_flag )', ' TODO: Not sure exactly what, if any, effect particles.setBounce() has.\n', 'api_particles.cpp#L59'],
		['particles.setColor', 'particles.setColor( particle_emitter_id, r,g,b, a )', ' Controls the color that the next, and all subsequent, particles will be - until this is called again.\n', 'api_particles.cpp#L86'],
		['particles.setCount', 'particles.setCount( particle_emitter_id, max_particle_count )', '', 'api_particles.cpp#L73'],
		['particles.setDisabled', 'particles.setDisabled( particle_emitter_id )', '', 'api_particles.cpp#L115'],
		['particles.setDrag', 'particles.setDrag( particle_emitter_id, particle_drag )', ' Alter the physics parameters.\n', 'api_particles.cpp#L100'],
		['particles.setEnabled', 'particles.setEnabled( particle_emitter_id )', '', 'api_particles.cpp#L127'],
		['particles.setEnergyMax', 'particles.setEnergyMax( particle_emitter_id, emax )', '', 'api_particles.cpp#L140'],
		['particles.setEnergyMin', 'particles.setEnergyMin( particle_emitter_id, energy_min_value )', ' Controls the minimum possible value for new particles energy values.\n Energy values are randomized to give the illusion of life.\n', 'api_particles.cpp#L153'],
		['particles.setGravity', 'particles.setGravity( particle_emitter_id, float_value )', ' Control the strength of gravity. -9.8 would be standard earth gravity.\n Force is applied in GL Y axis. TODO: Align particles gravity to planet.\n', 'api_particles.cpp#L168'],
		['particles.setHardDeck', 'particles.setHardDeck( particle_emitter_id, deck_altitude )', '', 'api_particles.cpp#L184'],
		['particles.setLife', 'particles.setLife( particle_emitter_id, life_span_in_seconds )', ' Controls how long each particle will live for.\n It is possible to "run out" of particles.\n You have a finite number and you MUST balance birth-rate:life:count variables.\n', 'api_particles.cpp#L198'],
		['particles.setOrigin', 'particles.setOrigin( particle_emitter_id, x,y,z )', '', 'api_particles.cpp#L215'],
		['particles.setOriginOffset', 'particles.setOriginOffset( particle_emitter_id, off_x,off_y,off_z )', '', 'api_particles.cpp#L251'],
		['particles.setScaleRate', 'particles.setScaleRate( particle_emitter_id, rate_value )', ' Create a new particle emitter that has a birth-size of 1.0\n Set the scale-rate to 2.0 using this function.\n When the particle engine runs, the particles will start with a size of 1.0 and when one-second has passed, they will have grown to a total size of 3.0\n', 'api_particles.cpp#L266'],
		['particles.setSize', 'particles.setSize( particle_emitter_id, size )', ' Control how big new particles are when they spawn.\n', 'api_particles.cpp#L283'],
		['particles.setStreamHeading', 'particles.setStreamHeading( particle_emitter_id, value )', '', 'api_particles.cpp#L366'],
		['particles.setStreamNoise', 'particles.setStreamNoise( particle_emitter_id, value )', '', 'api_particles.cpp#L379'],
		['particles.setStreamPitch', 'particles.setStreamPitch( particle_emitter_id, value )', '', 'api_particles.cpp#L353'],
		['particles.setStuckToAcf', 'particles.setStuckToAcf( particle_emitter_id, sticky )', '', 'api_particles.cpp#L301'],
		['particles.setTexture', 'particles.setTexture( particle_emitter_id, texture_id )', '', 'api_particles.cpp#L393'],
		['particles.setTextureSpriteCount', 'particles.setTextureSpriteCount( particle_emitter_id, nx,ny )', ' Set number of sprites in the texture, eg: 3x3 = 9. texture will be sub divided into grid regions.\n FIXME: gitbug:65 particles.setTextureSpriteCount() Doesnt actually effect the output result yet.\n', 'api_particles.cpp#L406'],
		['particles.setType_Cubic', 'particles.setType_Cubic( particle_emitter_id )', '', 'api_particles.cpp#L315'],
		['particles.setType_Spherical', 'particles.setType_Spherical( particle_emitter_id )', '', 'api_particles.cpp#L327'],
		['particles.setType_Stream', 'particles.setType_Stream( particle_emitter_id )', '', 'api_particles.cpp#L339'],
		['particles.start', 'particles.start( particle_emitter_id )', ' ........ redundant, we already have disable flag.\n', 'api_particles.cpp#L424']
		],
	'physics' : [
		['physics.applyForce', 'physics.applyForce( object_id, x,y,z )', ' \n Apply a force to the center of the object, force is specified as a vector.\n', 'api_physics.cpp#L21'],
		['physics.applyImpulse', 'physics.applyImpulse( object_id, x,y,z )', ' \n Apply an impulse to the center of the object, impulse is specified as a vector.\n', 'api_physics.cpp#L59'],
		['physics.applyOffsetImpulse', 'physics.applyOffsetImpulse( object_id, x,y,z )', ' \n FIXME: empty hook\n Apply a  to the center of the object,  is specified as a vector.\n', 'api_physics.cpp#L135'],
		['physics.applyTorque', 'physics.applyTorque( object_id, x,y,z )', ' \n Apply torque the center of the object, torque is specified as a vector.\n', 'api_physics.cpp#L159'],
		['physics.applyTorqueImpulse', 'physics.applyTorqueImpulse( object_id, x,y,z )', ' \n FIXME: empty hook\n Apply a  to the center of the object,  is specified as a vector.\n', 'api_physics.cpp#L147'],
		['physics.clearForces', 'physics.clearForces( object_id )', ' Clears any force parameters for the object.\n', 'api_physics.cpp#L196'],
		['physics.getAngularVelocity', 'physics.getAngularVelocity( object_id )', ' \n Returns: x,y,z\n \n API: >= 11.5.25\n', 'api_physics.cpp#L227'],
		['physics.getLinearVelocity', 'physics.getLinearVelocity( object_id )', ' \n Returns: x,y,z\n \n API: >= 11.5.25\n', 'api_physics.cpp#L261'],
		['physics.getOrientationQ', 'physics.getOrientationQ( object_id )', ' \n Returns: x,y,z,angle\n \n These values represent the attitude Quarternion for the specified object_id.\n \n API: >= 11.5.25\n', 'api_physics.cpp#L294'],
		['physics.loadCollada', 'physics.loadCollada( filename )', '\nBROKEN BROKEN BROKEN!\n\nNON functional.\n', 'api_physics.cpp#L964'],
		['physics.newBox', 'physics.newBox( edge_size )', ' \n Creates a new rigid body element in the physics engine.\n \n', 'api_physics.cpp#L824'],
		['physics.newCapsule', 'physics.newCapsule( radius, height )', ' \n Creates a new rigid body element in the physics engine.\n A capsule is a cylinder with domed ends.\n \n', 'api_physics.cpp#L889'],
		['physics.newCone', 'physics.newCone( radius, height )', ' \n Creates a new rigid body element in the physics engine.\n', 'api_physics.cpp#L923'],
		['physics.newCylinder', 'physics.newCylinder( radius, height, z )', ' \n  Creates a new rigid body element in the physics engine.\n \n', 'api_physics.cpp#L853'],
		['physics.newMultiSphere', 'physics.newMultiSphere( ........fubar )', ' \n Creates a new rigid body element in the physics engine.\n', 'api_physics.cpp#L953'],
		['physics.newSphere', 'physics.newSphere( radius )', ' \n Create a new sphere rigid body in the physics engine.\n', 'api_physics.cpp#L799'],
		['physics.restart', 'physics.restart()', ' \n Reset the physics engine.\n', 'api_physics.cpp#L440'],
		['physics.setAngularVelocity', 'physics.setAngularVelocity( id, x, y, z )', ' \n Apply force to rigid body instance.\n \n', 'api_physics.cpp#L366'],
		['physics.setBrush', 'physics.setBrush( object_id )', ' \n Set default brush for newly created objects.\n The brush_id controls what the physics object will look like when drawn on screen.\n It does NOT control the physics calculations for collisions.\n', 'api_physics.cpp#L671'],
		['physics.setBrushByID', 'physics.setBrushByID( physics_id, object_id )', ' \n Change the brush-id of a physics object.\n', 'api_physics.cpp#L697'],
		['physics.setCursor', 'physics.setCursor( x,y,z )', ' \n Move the physics spawn point in space.\n', 'api_physics.cpp#L727'],
		['physics.setDebugMode', 'physics.setDebugMode( debug_mode_flag )', ' \n Possible values:\n enum  \tDebugDrawModes { \n DBG_NoDebug = 0, \n DBG_DrawWireframe = 1, \n DBG_DrawAabb = 2, \n DBG_DrawFeaturesText = 4, \n DBG_DrawContactPoints = 8, \n DBG_NoDeactivation = 16, \n DBG_NoHelpText = 32, \n DBG_DrawText = 64, \n DBG_ProfileTimings = 128, \n DBG_EnableSatComparison = 256, \n DBG_DisableBulletLCP = 512, \n DBG_EnableCCD = 1024, \n DBG_DrawConstraints = (1 << 11), \n DBG_DrawConstraintLimits = (1 << 12), \n DBG_FastWireframe = (1<<13), \n DBG_MAX_DEBUG_DRAW_MODE \n }\n', 'api_physics.cpp#L754'],
		['physics.setEnabled', 'physics.setEnabled( int_flag )', ' \n Enable the physics engine.\n', 'api_physics.cpp#L508'],
		['physics.setGravityVector', 'physics.setGravityVector( x,y,z )', ' \n Set default graivty vector.\n Normal gravity is ( 0, -9.8, 0 )\n', 'api_physics.cpp#L598'],
		['physics.setInertia', 'physics.setInertia( vx,vy,vz )', ' \n Set default inertia value for newly created objects.\n', 'api_physics.cpp#L647'],
		['physics.setLinearVelocity', 'physics.setLinearVelocity( object_id, vx, vy, vz )', ' \n API: >= 11.5.25\n', 'api_physics.cpp#L332'],
		['physics.setMass', 'physics.setMass( new_default_mass )', ' \n Set the default mass value for new objects, ratio.\n', 'api_physics.cpp#L459'],
		['physics.setOrigin', 'physics.setOrigin( x,y,z )', ' \n Controls where in X-Planes OpenGL world the Bullet-Origin is.\n Bullets physics math works best with a 10x10x10 kilometer cube.\n Move it around.\n', 'api_physics.cpp#L621'],
		['physics.setPaused', 'physics.setPaused( int_flag )', ' \n Pause the physics engine.\n', 'api_physics.cpp#L538'],
		['physics.setPhysicsDrawingHack', 'physics.setPhysicsDrawingHack( int_flag )', ' \n Turns a physics drawing hack on and off, you MUST load an OBJ8 file (anyone will do) before turning this on.\n It\'s a _hack_.\n', 'api_physics.cpp#L479'],
		['physics.stepOnce', 'physics.stepOnce()', ' \n When paused, step the physics engine frame by frame.\n', 'api_physics.cpp#L569'],
		['physics.translate', 'physics.translate( id, x,y,z )', ' \n Translate a rigid body inside the physics world.\n \n API: >= 11.5.25\n', 'api_physics.cpp#L403']
		],
	'plugins' : [
		['plugins.findPlugin', 'plugins.findPlugin( signature )', '\nReturns: boolean\n \n<code>\nif( plugins.findPlugin( "custom_systems.xpl" ) )then\n\t--we could find the plugin and are capable of sending messages to it in a useful manner.\nend\n</code>\n\nAPI: >= 12.01\n', 'api_plugins.cpp#L23'],
		['plugins.getFolder', 'plugins.getFolder()', '\nReturns: String containing path to plugins folder. Includes trailing slash. All slashes are set to /\n\nEg: "/home/br/Desktop/X-Plane 10/Resources/plugins/"\n\n<code>--get plugins folder\nlocal plugins_folder_path = plugins.getFolder()\n\n</code>\n \nAPI: >= 11.5.25\n', 'api_plugins.cpp#L71'],
		['plugins.sendBlob', 'plugins.sendBlob( signature, code, message )', '\nReturns: true if signature was found and message sent, nil otherwise.\n\n<code>\nplugins.sendMessage( "xplanesdk.examples.DataRefEditor", 0x01000000, "myproject/custom/dataref_name" )\n--this would try to register a fake dataref with DRE.\n</code>\n\nAs of 2013.07.01 this function will auto detect the type of data you are sending as "message".\n\nIf you are sending a string value it will be passed over IPC as a C-String pointer.\n\nIf you are sending a numeric value (may include strings that can be cleanly converted to numeric!) then it will be sent as an unsigned  long int.\n\nData packet will be auto packaged with a 4 byte header to indicate the size of the payload.\nThis allows one shot binary packet xfer over the ixplc channel.\n\nAPI: >= 13.07\n', 'api_plugins.cpp#L182'],
		['plugins.sendMessage', 'plugins.sendMessage( signature, code, message )', '\nReturns: true if signature was found and message sent, nil otherwise.\n\n<code>\nplugins.sendMessage( "xplanesdk.examples.DataRefEditor", 0x01000000, "myproject/custom/dataref_name" )\n--this would try to register a fake dataref with DRE.\n</code>\n\nAs of 2013.07.01 this function will auto detect the type of data you are sending as "message".\n\nIf you are sending a string value it will be passed over IPC as a C-String pointer.\n\nIf you are sending a numeric value (may include strings that can be cleanly converted to numeric!) then it will be sent as an unsigned  long int.\n\nAPI: >= 13.07\n', 'api_plugins.cpp#L100']
		],
	'prefs' : [
		['prefs.get', 'prefs.get( key_name, default_value )', '\nReturns: Value of prefs key or default_value if prefs key_name was not found.\n\nGet a prefs value.\n\n<code>\nlocal var = prefs.get( "foo_bar", 1.234 )\n</code>\n\nAPI: >= 14.04\n', 'prefs_api.lua#L178'],
		['prefs.load', 'prefs.load()', '\nReturns: nothing\n\nLoad prefs from disk.\n\n<code>\nprefs.load()\n</code>\n\nAPI: >= 14.04\n', 'prefs_api.lua#L19'],
		['prefs.save', 'prefs.save()', '\nReturns: nothing\n\nSave prefs to disk.\n\n<code>\nprefs.save()\n</code>\n\nAPI: >= 14.04\n', 'prefs_api.lua#L85'],
		['prefs.set', 'prefs.set( key_name, value_var )', '\nReturns: nothing\n\nSet a prefs value.\n\nDoes not save to disk.\n\n<code>\nprefs.set( "foo_bar", 1.234 )\n</code>\n\nAPI: >= 14.04\n', 'prefs_api.lua#L128']
		],
	'shaders' : [
		['shaders.compile', 'shaders.compile( shader_id, vertex_shader_string_blob, fragment_shader_string_blob )', ' Returns: boolean for success\n', 'api_shaders.cpp#L36'],
		['shaders.newShader', 'shaders.newShader()', ' Returns: shader_id\n', 'api_shaders.cpp#L21'],
		['shaders.release', 'shaders.release()', '\nReturns: nothing\n\nReturn GL to XP default drawing shaders.\n\nAPI: >= 12.01\n', 'api_shaders.cpp#L71'],
		['shaders.setParam', 'shaders.setParam( shader_id, param_name, value )', '\nReturns: nothing\n\nAllows passing of dynamic parameters into the shader.\nparam_name is a string, value is a floating point number\n\n<code>\nshaders.setParam( shader_x, "light_level", 2.0 )\n</code>\n\nAPI: >= 12.01\n', 'api_shaders.cpp#L91'],
		['shaders.use', 'shaders.use( shader_id )', ' Activate the specified valid shader_id.\n', 'api_shaders.cpp#L59']
		],
	'sound' : [
		['sound.getControl', 'sound.getControl()', '\nReturns: nothing\n\nAquires control of the shared X-Plane OpenAL context.\n\nYou MUST use this before any other LuaAL functions will work.\n\nThis function is automatically handled by all the general purpose sound control functions defined by the sound API.\nYou will only need to use this function call if you are using the al API directly for advanced sound control.\n\nSee the "sound_api.lua" in the Gizmo-Firmware project for more information.\nhttps://github.com/benrussell/Gizmo-Firmware/blob/master/firmware/core/sound_api.lua\n\n<code>\n--Example code taken directly from firmware/core/sound_api.lua\n--See URL above for more.\nsound.play = function( source_id )\n\tsound.getControl()\n\t\tal.SourcePlay( source_id )\n\tsound.releaseControl()\nend\n</code>\n\nAPI: >= 12.01\n', 'api_sound.cpp#L235'],
		['sound.load', 'sound.load( OPT_sound_buffer_id, sound_filename )', '\nReturns: sound_buffer_id\n\nOptional Parameter: sound_buffer_id\n\nIf called with no sound_buffer_id argument a new sound buffer will be created for you.\n\nYou must use sound.bind( sound_source_id, sound_buffer_id ) and sound.play( sound_source_id ) to make use of your loaded sound data.\n\nFile Formats Supported:\n-----------------------\n* WAV Files:\n\tSample Rate:\t22 or 44kz\n\tBit Depth:\t\t8 or 16 bit\n\tChannels:\t\tMono or Stereo\n\nNote: \n\tThe OpenAL programmers guide recommend that Stereo WAV files will \n\tNOT render correctly on a 3D sound stage.\n\t\n\tUse Mono samples only if you expect to be manipulating sound positions.\n\n<code>\n--Create a new sound source, analagous to a Loud Speaker in real life.\nlocal sndsrc_Alert = sound.newSource()\n\n--Load our sound sample data and save the new sound_buffer_id that\'s returned.\nlocal snd_Alert = sound.load( acf.getFolder() .. "sounds/alert.wav" )\n\n--Bind our newly loaded sound to our newly created sound source.\nsound.bind( sndsrc_Alert, snd_Alert )\n\n--Play the sound.\nsound.play( sndsrc_Alert )\n</code>\n\nAPI: >= 12.01\n', 'api_sound.cpp#L106'],
		['sound.newBuffer', 'sound.newBuffer()', '\nReturns: sound_buffer_id\n\nAllocates a new sound buffer and returns its ID.\n\n<code>\nlocal sndbuff_Alert = sound.newBuffer()\n</code>\n\nAPI: >= 12.01\n', 'api_sound.cpp#L58'],
		['sound.newSource', 'sound.newSource()', '\nReturns: sound_source_id\n\nAllocates a new sound source and returns its ID.\n\n<code>\nlocal sndsrc_Alert = sound.newSource()\n</code>\n\nAPI: >= 12.01\n', 'api_sound.cpp#L82'],
		['sound.pause', 'sound.pause( sound_source_id )', '\nPause the playback of the specified sound.\n', 'sound_api.lua#L50'],
		['sound.play', 'sound.play( sound_source_id )', '\nPlay the specified sound. Resumes from paused state if sound was paused.\nSee sound.rewind(...)\n', 'sound_api.lua#L62'],
		['sound.releaseControl', 'sound.releaseControl()', '\nReturns: nothing\n\nReleases control of the shared X-Plane OpenAL context.\n\nYou MUST use this after calling: sound.getControl()\n\nThis function is automatically handled by all the general purpose sound control functions defined by the sound API.\nYou will only need to use this function call if you are using the al API directly for advanced sound control.\n\nSee the "sound_api.lua" in the Gizmo-Firmware project for more information.\nhttps://github.com/benrussell/Gizmo-Firmware/blob/master/firmware/core/sound_api.lua\n\n<code>\n--Example code taken directly from firmware/core/sound_api.lua\n--See URL above for more.\nsound.play = function( source_id )\n\tsound.getControl()\n\t\tal.SourcePlay( source_id )\n\tsound.releaseControl()\nend\n</code>\n\nAPI: >= 12.01\n', 'api_sound.cpp#L273'],
		['sound.rewind', 'sound.rewind( sound_source_id )', '\nMove the playhead for a given sample back to the start of a sample.\n', 'sound_api.lua#L75'],
		['sound.say', 'sound.say( string_to_vocalize )', '\nReturns: nothing\n\nX-Plane will speak your text using the text-to-speech processor.\n\nResults should be the same as the built in ATC system.\n\n<code>\nsound.say("Hello World!")\n</code>\n\nAPI: >= 12.01\n', 'api_sound.cpp#L14'],
		['sound.setDirection', 'sound.setDirection( sound_source_id, nx,ny,nz )', '\nControls the direction vector that the sound is travelling in.\n', 'sound_api.lua#L99'],
		['sound.setGain', 'sound.setGain( sound_source_id, gain_ratio )', '\nControls the gain, or volume, of a sound sample, argument is a ratio.\n', 'sound_api.lua#L139'],
		['sound.setLoop', 'sound.setLoop( sound_source_id, loop_flag )', '\nSet loop_flag to 1 and the sound will play forever until stopped or paused.\nSet loop_flag to 0 and the sound will stop playing when the end of the sample is reached.\n', 'sound_api.lua#L151'],
		['sound.setPitch', 'sound.setPitch( sound_source_id, pitch_ratio )', '\nAlter the pitch ratio of a given sound.\n0.5 will play at half pitch.\n2.0 will play at twice-normal pitch.\n1.0 will play normally.\n', 'sound_api.lua#L164'],
		['sound.setPosition', 'sound.setPosition( sound_source_id, x,y,z )', '\nSet the sounds position in 3D space.\n\nMono files only for 3D sound-stage use.\n', 'sound_api.lua#L179'],
		['sound.setVelocity', 'sound.setVelocity( sound_source_id, vx,vy,vz )', '\nControls the velocity of the sound in 3D space.\nCombine this with sound.setDirection(...)\n\n', 'sound_api.lua#L220'],
		['sound.stop', 'sound.stop( sound_source_id )', '\nStops playback for a given sound, moves playhead back to start of sample.\n', 'sound_api.lua#L87']
		],
	'string' : [
		['string.read_me', 'string.read_me()', ' \nGizmo64 provides the full Lua string API.\n\nhttp://www.lua.org/manual/5.2/manual.html#6.4\n\n', 'api_third_party_docs.cpp#L351']
		],
	'table' : [
		['table.read_me', 'table.read_me()', '\nGizmo64 provides the full Lua table API.\n\nhttp://www.lua.org/manual/5.2/manual.html#6.5\n\n', 'api_third_party_docs.cpp#L367']
		],
	'timer' : [
		['timer.destroy', 'timer.destroy( timer_id )', '\nReturns: nothing\n\nStop and destroys a timer.\n\n<code>\n--Stop and destroy a timer.\ntimer.destroy( tmr_TickTock )\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L257'],
		['timer.getHPT', 'timer.getHPT()', '\nReturns: Integer. Number of microseconds that have elapsed since Gizmo64 started.\n\n<code>\n--Basic timing measurement for a theoretical drawing call function.\n--Allows measurement of runtime and therefore optimization of drawing callsin\n\n--Grab a reference time stamp.\nlocal start_time = timer.getHPT()\n\n\t--Call the drawing code that we want to measure.\n\tcall_drawing_function()\n\n--Take a second time stamp.\nlocal stop_time = timer.getHPT()\n\n--Calculate the difference between the start and the end time stamps.\nlocal delta = stop_time - start_time\n\nsound.say("draw call took: " .. delta .. " microseconds.")\n</code>\n\nAPI >= 12.11.08\n', 'api_timer.cpp#L376'],
		['timer.getInterval', 'timer.getInterval( timer_id )', '\nReturns: Float. Timer interval value.\n\nUse this function to examine how often a timer executes.\n\nUse the function <i>timer.setInterval( timer_id, new_interval )</i> to adjust the interval.\n\n<code>\nlocal timer_interval = timer.getInterval( tmr_TickTock )\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L463'],
		['timer.getValue', 'timer.getValue( timer_id )', '\nReturns: Float. The current value of a timer. Can be used to calculate current progress %.\n\n<code>\nlocal max_time = 10\n\nlocal curr_value = timer.getValue( tmr_TickTock )\n\nlocal progress_pct = (curr_value / max_time)\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L415'],
		['timer.newOneShot', 'timer.newOneShot( timer_function_name, interval_seconds )', '\nReturns: timer_id\n\nCreate a timer that will fire once and die.\n\n<code>\n--Create a function that defines what the timer will do..\nfunction oneshot_action()\n\tsound.say("Hello One Shot World!")\nend\n\n--create a new one-shot timer that will execute our oneshot_action() function in 5 seconds.\nlocal tmr_oneshot = timer.newOneShot( "oneshot_action", 5.0 )\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L38'],
		['timer.newTimer', 'timer.newTimer( timer_function_name, interval )', '\nReturns: timer_id\n\nCreate a timer that will fire repeatedly forever until stopped.\n\n<code>\n--Create a function that defines what the timer will do..\nfunction repeating_action()\n\tsound.say("Hello Repeating World!")\nend\n\n--create a new repeating timer that will execute our repeating_action() function every 5 seconds until stopped.\nlocal tmr_repeating = timer.newTimer( "repeating_action", 5.0 )\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L112'],
		['timer.reset', 'timer.reset( timer_id )', '\nReturns: nothing\n\nResets the internal value of a timer and restarts it.\n\nThis function will restart a timer_id that has been stopped using: timer.stop()\n\n<code>\n--stop our timer.\ntimer.stop( tmr_repeating_task )\n</code>\n\n<code>\n--create a function that can be called by a one-shot timer.\nfunction restart_timer_after_delay()\n\t--restart our stopped timer.\n\ttimer.reset( tmr_repeating_task )\nend\n\n--create a one shot timer to restart our stopped timer after 1.5 seconds.\ntimer.newOneShot( "restart_timer_after_delay", 1.5 )\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L315'],
		['timer.setInterval', 'timer.setInterval( timer_id, interval )', '\nReturns: nothing\n\nUse this function to modify how often a timer executes.\n\nUse the function <i>timer.getInterval( timer_id )</i> to adjust the interval.\n\n<code>\nlocal timer_interval = 120\ntimer.setInterval( tmr_TickTock, timer_interval )\n</code>\n\nAPI: >= 12.01\n\n', 'api_timer.cpp#L509'],
		['timer.stop', 'timer.stop( timer_id )', '\nReturns: nothing\n\nStops a timer. The function for timer_id will not be called again.\n\nUse timer.reset( timer_id ) to restart a timer that has been stopped.\n\n<code>\n--stop our timer.\ntimer.stop( tmr_repeating_task )\n</code>\n\n<code>\n--create a function that can be called by a one-shot timer.\nfunction restart_timer_after_delay()\n\t--restart our stopped timer.\n\ttimer.reset( tmr_repeating_task )\nend\n\n--create a one shot timer to restart our stopped timer after 1.5 seconds.\ntimer.newOneShot( "restart_timer_after_delay", 1.5 )\n</code>\n\nAPI: >= 12.01\n', 'api_timer.cpp#L191']
		],
	'toast' : [
		['toast.newError', 'toast.newError( caption, message )', '\nReturns: nothing\n\nDisplay an error message on screen.\n\n<code>\ntoast.newError( "toast", "message data" )\n</code>\n\nAPI: >= 14.04\n', 'toast_api.lua#L141'],
		['toast.newHelp', 'toast.newHelp( caption, message )', '\nReturns: nothing\n\nDisplay an help message on screen.\n\n<code>\ntoast.newHelp( "toast", "message data" )\n</code>\n\nAPI: >= 14.04\n', 'toast_api.lua#L204'],
		['toast.newInfo', 'toast.newInfo( caption, message )', '\nReturns: nothing\n\nDisplay an info message on screen.\n\n<code>\ntoast.newInfo( "toast", "message data" )\n</code>\n\nAPI: >= 14.04\n', 'toast_api.lua#L183'],
		['toast.newWarning', 'toast.newWarning( caption, message )', '\nReturns: nothing\n\nDisplay an warning message on screen.\n\n<code>\ntoast.newWarning( "toast", "message data" )\n</code>\n\nAPI: >= 14.04\n', 'toast_api.lua#L162']
		],
	'trig' : [
		['trig.courseToLocation', 'trig.courseToLocation( x,y )', '\nReturns: Float. Heading in degrees.\n\n<code>--compute course to target\nlocal target_h = trig.courseToLocation( x,y )\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L12'],
		['trig.courseToLocation3D', 'trig.courseToLocation3D( x,y,z )', '\nReturns: Floats. pitch and heading in degrees\n\n<code>--Get pitch and heading in degrees to track our target position in x,y,z space.\nlocal p,h = trig.courseToLocation3D( x,y,z )\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L41'],
		['trig.distanceBetweenPoints', 'trig.distanceBetweenPoints( a,b, x,y )', '\nReturns: Float. Distance.\n\nUses flat plane geometry.\n\n<code>--Get distance between points..\nlocal target_dist = trig.distanceBetweenPoints( a,b, x,y )\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L74'],
		['trig.distanceBetweenWorldPoints', 'trig.distanceBetweenWorldPoints( lat_a,lon_a, lat_b,lon_b )', '\nReturns: Float. Distance in "degrees of latitude".\n\nUses decent spherical geometry translated from web source: ...... (SDK website has it??)\n\nMultiply return value by 60 to convert to nautical miles.\n\n<code>\nlocal target_lat, target_lon = 30, 140 --Randomly selected target data.\n\nlocal acf_lat, acf_lot, acf_alt = acf.getPosition()\n\nlocal target_distance = trig.distanceBetweenWorldPoints( acf_lat, acf_lon,  target_lat, target_lon )\n\nlocal target_distance_nm = target_distance * 60.0\n\nsound.say("distance to target: " .. string.format("%0.1f nautical miles", target_distance_nm) )\n</code>\n\n\nCore Math - Not example code!:\n<code>\nreturn ( 2 *\n\t\tasin(\n\t\t\tsqrt(\n\t\t\t\tsqr( (sin((lat1-lat2)/2)) ) +\n\t\t\t\tcos(lat1) *\n\t\t\t\tcos(lat2) *\n\t\t\t\tsqr( (sin((lon1-lon2)/2)) )\n\t\t\t)\n\t\t)\n\t);\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L109'],
		['trig.interpolator', 'trig.interpolator( r,s,t, x,y,z, steps )', '\nReturns: Stream of x,y,z positions as stream-table.\n\nr,s,t: Start position in XYZ space.\nx,y,z: Finish position in XYZ space.\n\nReturn data example: { x,y,z, x,y,z, x,y,z, x,y,z, ... }\nEach x,y,z set is a new 3D fix.\n\n<code>\n--Start position XYZ\nlocal r,s,t = 0,0,0\n\n--Finish position XYZ\nlocal x,y,z = 10,2,4\n\n--How many moves are we allowed?\nlocal steps = 50\n\n--Gather data stream...\nlocal xyz_stream = { trig.interpolator( r,s,t, x,y,z, steps ) }\n\n--We should now have steps * 3 elements in the table xyz_stream\n</code>\n\n<code>\n--Do something with our data stream from the interp..\nlocal max_segments = #xyz_stream / 3\n\n--Move through the stream in jumps of 3 items.\nfor seg_x=1, max_segments, 3 do\n\n\t--Extract a set of xyz data out of the stream..\n\tlocal sx = xyz_stream[seg_x]\n\tlocal sy = xyz_stream[seg_x+1]\n\tlocal sz = xyz_stream[seg_x+2]\n\t\n\t--draw something?\n\t--gfx.draw...( sx,sy,sz )\n\t\nend\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L243'],
		['trig.newPositionOffset', 'trig.newPositionOffset( heading, speed )', '\nReturns: x,y as floating point values.\n\nGiven a spead and heading, calculate a new grid position.\n\n<code>\n--New target location:\nlocal new_xy = { trig.newPositionOffset( 270, 1000 ) }\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L170'],
		['trig.newPositionOffset3D', 'trig.newPositionOffset3D( heading, pitch, speed )', '\nReturns: x,y,z as floating point values.\n\nGiven heading, pitch and speed, return x,y,z data for result.\n\n<code>\n--New 3D target location:\nlocal new_xyz = { trig.newPositionOffset3D( 270, 1000 ) }\n</code>\n\nAPI: >= 12.01\n', 'api_trig.cpp#L206']
		],
	'utils' : [
		['utils.expScale', 'utils.expScale( input, scale_factor )', '\r\nReturns: exponentially scaled value.\r\n\r\n<code>--Use for gain manipulations.\r\nlocal raw_input = joystick.getPitch()\r\nlocal new_value = utils.expScale( raw_input, 0.75 )\r\n</code>\r\n\r\nAPI: >= 12.01\r\n', 'api_utils.cpp#L30'],
		['utils.getBlobFromCPointer', 'utils.getBlobFromCPointer( pointer_address )', '\r\nReturns: String value at pointer address.\r\n\r\nThis function auto decodes a blob of the format:\r\n<i>{ size[4], bytes[...] }</i>\r\n\r\nThe size header will be automatically parsed and stripped away leaving you with blob data.\r\n\r\nUseful when combined with: <i>plugins.sendBlob( target, msg, blob, blob_length )</i> which is capable of autopackaging into the correct format.\r\n\r\nWARNING: Experts only, will crash X-Plane to desktop if not used correctly.\r\n\r\n<code>--DANGER: Abuse of this code can and will crash your simulator.\r\nlocal new_message = utils.getBlobFromCPointer( message_address )\r\n</code>\r\n\r\nAPI: >= 11.4\r\n', 'api_utils.cpp#L452'],
		['utils.getFileInfo', 'utils.getFileInfo( file_path )', '\r\nReturns: node_type, size_in_bytes, date_changed\r\n\r\nThis function is capable of returing information about many types of file system resources.\r\n\r\nBe sure to inspect the node_type return value when performing IO operations.\r\n\r\nThe most commonly used values are "folder" and "file". \r\n\r\n\r\nOther values are retained for advanced use as required.\r\nValid "node_type" values:\r\n\t"block_dev"\r\n\t"char_dev"\r\n\t"folder"\r\n\t"fifo"\r\n\t"symlink"\r\n\t"file"\r\n\t"socket"\r\n\t"unknown"\r\n\r\n<code>--Inspect the date_changed for the users aircraft file.\r\nlocal file_info = { utils.getFileInfo(acf.getFolder() .. acf.getFilename()) }\r\n\r\nsound.say("aircraft last changed: " .. file_info[3])\r\n</code>\r\n\r\nAPI: 11.14+\r\n', 'api_utils.cpp#L287'],
		['utils.getFolderContents', 'utils.getFolderContents( folder_path )', '\r\nReturns: Multiple strings containing the names of the items found in the folder specified.\r\n\r\nNOTE: Due to a limit in Mac OS "Classic" the max recommended length for a filename is 31 chars.\r\nUse of filenames longer than this may result in cross-plaform issues.\r\n\r\n<code>--Collect a list of filenames for a specified folder into a new Lua table called file_list\r\nlocal file_list = { utils.getFolderContents(acf.getFolder()) }\r\n</code>\r\n\r\nAPI: >= 11.11\r\n', 'api_utils.cpp#L62'],
		['utils.getStringFromCPointer', 'utils.getStringFromCPointer( pointer_address, OPT_length )', '\r\nReturns: String value at pointer address.\r\n\r\nWARNING: Experts only, will crash X-Plane to desktop if not used correctly.\r\n\r\nThe length parameter is optional.\r\nIf omitted Gizmo64 will attempt to return the C-String(null terminated array) value at the ram address specified.\r\nThis may crash the Simulator to Desktop.\r\n\r\nThis function DOES NOT use a custom blob format during data interchange.\r\nIt provides direct access to system ram addresses with no decode layer.\r\n\r\nUse utils.getBlobFromCPointer(...) if you require framed data interchange.\r\n\r\n<code>--get me a chunk of that raw ram stuff.\r\nlocal danger_danger = utils.getStringFromCPointer( pointer_address, 256 )\r\n</code>\r\n\r\nAPI >= 11.4+\r\n', 'api_utils.cpp#L500'],
		['utils.newFolder', 'utils.newFolder( folder_path )', '\r\nReturns: nothing\r\n\r\nAttempts to create a new folder.\r\n\r\nNOTE: Due to a limit in Mac OS "Classic" the max recommended length for a filename is 31 chars.\r\nUse of filenames longer than this may result in cross-plaform issues.\r\n\r\n<code>--Create a new folder in the X-Plane folder.\r\nutils.newFolder( xp.getFolder() .. "new_folder" )\r\n</code>\r\n\r\nAPI: >= 12.01.28\r\n', 'api_utils.cpp#L211'],
		['utils.popWebBrowser', 'utils.popWebBrowser( url )', '\r\nReturns: nothing\r\n\r\nOpens the system default web browser and sends user to specified URL.\r\n\r\n<code>--Open a URL in a web browser..\r\nutils.popWebBrowser("http://benrussell.github.io/");\r\n</code>\r\n\r\nAPI: >= 11.5.6\r\n', 'api_utils.cpp#L546'],
		['utils.setClipboardText', 'utils.setClipboardText( string_data )', '\r\nReturns: nothing\r\n\r\nCopy string_data to the system clipboard.\r\n\r\nThe value of the clipboard cannot be read by Gizmo64 scripts for privacy protection.\r\n\r\n<code>--Set the users clipboard value.\r\nutils.setClipboardText("Gizmo64 rocks!")\r\n</code>\r\n\r\nMac/Win only.\r\n\r\nAPI: >= 13.02.24\r\n', 'api_utils.cpp#L606']
		],
	'xp' : [
		['xp.clearReplay', 'xp.clearReplay()', '\nReturns: nothing.\n\nClears the X-Plane replay buffer.\n\n<code>xp.clearReplay()\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L15'],
		['xp.commandBeginByName', 'xp.commandBeginByName( command_name )', '\nReturns: nothing\n\nEquivalent to pressing-and-holding a joystick button or hotkey for the named command.\n\nX-Plane will call the hold down event until you call xp.commandEndByName( command_name )\n\n<code>--Begin a command press event\nxp.commandBeginByName( "sim/foo/button" )\n</code>\n<code>--Some time later on, release the button..\nxp.commandEndByName( "sim/foo/button" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L39'],
		['xp.commandEndByName', 'xp.commandEndByName( command_name )', '\nReturns: nothing\n\nEquivalent to releasing a joystick button or hotkey for the named command.\n\nUse after calling xp.commandBeginByName( command_name )\n\n<code>--Begin a command press event\nxp.commandBeginByName( "sim/foo/button" )\n</code>\n<code>--Some time later on, release the button..\nxp.commandEndByName( "sim/foo/button" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L75'],
		['xp.commandOnceByName', 'xp.commandOnceByName( command_name )', '\nReturns: nothing\n\nEquivalent to momentarily pressing a joystick button or hotkey for the named command.\n\n<code>--Trigger a command press event.\nxp.commandOnceByName( "sim/foo/button" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L111'],
		['xp.getCycleNumber', 'xp.getCycleNumber()', '\nReturns: number of frames rendered since sim started as an integer value.\n\n<code>local sim_total_frame_count = xp.getCycleNumber()\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L153'],
		['xp.getElapsedTime', 'xp.getElapsedTime()', '\nReturns: Number of seconds since sim started as floating point value.\n\n<code>local sim_total_run_time = xp.getElapsedTime()\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L172'],
		['xp.getFolder', 'xp.getFolder()', '\nReturns: String containing path to X-Plane folder, includes trailing slash. All slashes are set to /\n\n<code>local xp_folder_path = xp.getFolder()\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L216'],
		['xp.getLanguage', 'xp.getLanguage()', '\nReturns: Language as Top Level Domain Code in a string.\n\nPossible return values:\n"??" - Unknown\n"us" - English\n"fr" - French\n"de" - German\n"it" - Italian\n"es" - Spanish\n"kr" - Korean\n"ru" - Russian\n"gr" - Greek\n"jp" - Japanese\n"cn" - Chinese\n"?!" - Unexpected return from XPLMGetLanuage() function. SNAFU. Note the !\n\n<code>--Detect and react to language settings\n\nlocal language_table = {}\n\nlocal user_language = xp.getLanguage()\n\nif( user_language == "en" )then\n\tlanguage_table = { label="Action" }\nelse if( user_language == "de" )then\n\tlanguage_table = { label="Achtung" }\nend\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L235'],
		['xp.getOS', 'xp.getOS()', '\nReturns: String value. "WIN", "LIN" or "MAC".\n\n<code>--if windows, do something different..\nif( xp.getOS() == "WIN" )then\n\tsound.say("Windows detected!")\nend\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L304'],
		['xp.getPaused', 'xp.getPaused()', '\nReturns: boolean\n\n<code>--Detection of sim paused state, useful for systems update toggles.\nif( not xp.getPaused() )then\n\t--sim is NOT paused, do stuff\nelse\n\t--sim is paused, pause custom systems\nend\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L190'],
		['xp.getSDKVersion', 'xp.getSDKVersion()', '\nReturns: X-Plane Plugin SDK version as decimal number eg: 2.00\n\n<code>--Detect SDK version as some code may depend on availability in future.\nlocal sdk_version = xp.getSDKVersion()\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L366'],
		['xp.getTerrainData', 'xp.getTerrainData( x,y,z )', '\nReturns: x,y,z, nx,ny,nz, vx,vy,vz, wet\n\nWhere:\nx,y,z\t\t: Position in OpenGL space where terrain probe hit terrain polygon. Y value contains terrain height.\nnx,ny,nz\t: Normal of polygon that terrain probe hit. Contains slope data for hitting the side of a mountain.\nvx,vy,vz\t: Velocity data in meters per second(?) for polygon that terrain probe hit. Allows for pitching ship deck.\nwet\t    \t: The terrain polygon that we hit was wet. This is a river, lake, stream or ocean.\n\nAll position related data is in OpenGL space.\nUse gfx.worldToLocal(...) and gfx.localToWorld(...) to translate between a geo-fix and X-Plane GL space.\n\nThe value for wet is either 0 or 1. 0 is dry. 1 is wet.\n\n<code>--Get terrain info for terrain directly below aircraft.\n\n--Fetch position data for aircraft in GL space.\nlocal acfx,acfy,acfz = acf.getPositionGL()\n\n--Query terrain data under our aircraft.\nlocal x,y,z, nx,ny,nz, vx,vy,vz, wet = xp.getTerrainData( acfx,acfy,acfz )\n\nif( wet == 1 )then\n\t--we are over water\nelse\n\t--we are over land\nend\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L397'],
		['xp.getVersion', 'xp.getVersion()', '\nReturns: Floating point number containing X-Plane version.\n\nEg: 10.20\n\n<code>--detect sim version number and test for compatability.\nif( xp.getVersion() < 10.3 )then\n\t--Our mod is not compatible with old versions of X-Plane.\n\tsound.say("Please upgrade X-Plane to at least 10.30 to run this code.")\nelse\n\t--continue loading...\nend\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L333'],
		['xp.loadReplay', 'xp.loadReplay( filename )', '\nReturns: nothing\n\nLoads a replay movie.\n\nNOTE: This will probably hang/block the sim while the replay file loads.\nThis can take a while, it is recommended you display a message to the user -before- calling this function.\n\n<code>\n--Load a replay file from disk.\nxp.loadReplay( "Output/replays/replay.mov" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L519'],
		['xp.loadSituation', 'xp.loadSituation( filename )', '\nReturns: nothing\n\nLoads a pre-saved situation file.\n\nNOTE: This will probably hang/block the sim while the replay file loads.\nThis can take a while, it is recommended you display a message to the user -before- calling this function.\n\n<code>\n--Load a pre-saved situation file.\nxp.loadSituation( "Output/situations/filename.sit" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L557'],
		['xp.newCommand', 'xp.newCommand( command_name, description, script_function_name )', '\nReturns: cmd_id\n\nRegisters a new custom command and makes it available for use inside X-Plane.\n\n<code>--Create a new Custom Command Handler.\ncmd_CustomCommandCanopyOpen = xp.newCommand("my/custom/command/canopy_open", "Open the canopy.", "canopy_open" )\n</code>\n\nSetup your scripted event handler code:\n<code>--Custom Event Handlers for command logic functionality.\nfunction canopy_open_OnStart()\n\t--button or key press started\n\n\tconsole.log("_OnStart")\n\t\n\t--If you want to recieve _OnHold and _OnStop notices you need to return 1 from this function.\n\treturn 1\nend\n\nfunction canopy_open_OnHold()\n\t--button or key is being held down\n\tconsole.log("_OnHold")\nend\n\nfunction canopy_open_OnStop()\n\t--button or key was released\n\tconsole.log("_OnStop")\nend\n</code>\n\nYou can also use your command via the xp.command...(...) API calls, eg:\n<code>--Calling a custom command as though it was a sim command.\nxp.commandOnceByName( "my/custom/command/canopy_open" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L596'],
		['xp.reloadScenery', 'xp.reloadScenery()', '\nReturns: nothing\n\nCalls for scenery system reload. Thrown in for completeness.\n\nNOTE: This will probably hang the sim visuals momentarily. Untested.\n\n<code>--Reload scenery data:\nxp.reloadScenery()\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L717'],
		['xp.saveReplay', 'xp.saveReplay( replay_filename )', '\nReturns: nothing\n\nSave a replave movie to disk.\nThis is NOT a quicktime movie.\n\n<code>--Save a replay movie to disk..\nxp.saveReplay( "Output/replays/replay.mov" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L746'],
		['xp.saveSituation', 'xp.saveSituation( sit_filename )', '\nReturns: nothing\n\nSave a situation file to disk.\n\n<code>--Save a situation file to disk..\nxp.saveSituation( "Output/situations/filename.sit" )\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L781'],
		['xp.setPaused', 'xp.setPaused( integer_flag )', '\nReturns: nothing\n\nPause or Unpause the simulation.\n\n<code>xp.setPaused( 1 ) --pause\nxp.setPaused( 0 ) --unpause\n</code>\n\nAPI: >= 12.01\n', 'api_xp.cpp#L483']
		]
};